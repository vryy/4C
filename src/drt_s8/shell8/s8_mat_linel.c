/*----------------------------------------------------------------------------*/
/*! \file
\brief shell8

\level 1

\maintainer Christoph Meier

*/
/*---------------------------------------------------------------------------*/
#ifdef D_SHELL8
#include "../../headers/standardtypes.h"
#include "shell8.h"


/*----------------------------------------------------------------------*
 |  r(I) = A(I,K)*b(K)*factor -----  r = A*b*factor          m.gee 6/01 |
 |  or                                                                  |
 |  r(I) += A(I,K)*b(K)*factor                                          |
 *----------------------------------------------------------------------*/
void math_matvecdense(DOUBLE *r, DOUBLE **A, DOUBLE *b, INT ni, INT nk, INT init, DOUBLE factor)
{
  INT i, k;
  DOUBLE sum;
  /*----------------------------------------------------------------------*/
  if (init == 0)
  {
    for (i = 0; i < ni; i++) r[i] = 0.0;
  }
  for (i = 0; i < ni; i++)
  {
    sum = 0.0;
    for (k = 0; k < nk; k++) sum += A[i][k] * b[k];
    r[i] += sum * factor;
  }
  /*----------------------------------------------------------------------*/
  return;
} /* end of math_matvecdense */


/*----------------------------------------------------------------------*
 | st.venant-kirchhoff-material                           m.gee 6/01    |
 *----------------------------------------------------------------------*/
void s8_mat_linel(STVENANT *mat, DOUBLE **g, DOUBLE **CC)
{
  INT i, j, k, l;

  /*----- shear correction coefficient not yet introduced */
  /* DOUBLE xsi=1.0;  */

  DOUBLE C[3][3][3][3]; /*--------------------------- constitutive tensor */
  DOUBLE l1, l2;        /*----------------------------------------- lame constants */
  DOUBLE emod, nue;     /*--------------------------------------- mat constants */
  /*----------------------------------------------------------------------*/
  emod = mat->youngs;
  nue = mat->possionratio;
  l1 = (emod * nue) / ((1.0 + nue) * (1.0 - 2.0 * nue));
  l2 = emod / (2.0 * (1.0 + nue));
  /*---------this is not very fast, but corresponds nicely with theory... */
  for (i = 0; i < 3; i++)
    for (j = 0; j < 3; j++)
      for (k = 0; k < 3; k++)
        for (l = 0; l < 3; l++)
          C[i][j][k][l] = l1 * g[i][j] * g[k][l] + l2 * (g[i][k] * g[j][l] + g[i][l] * g[k][j]);
  /*----------------------------------------------------------------------*/
  CC[0][0] = C[0][0][0][0];
  CC[0][1] = C[0][0][1][0];
  CC[0][2] = C[0][0][2][0];
  CC[0][3] = C[0][0][1][1];
  CC[0][4] = C[0][0][2][1];
  CC[0][5] = C[0][0][2][2];

  CC[1][0] = C[1][0][0][0];
  CC[1][1] = C[1][0][1][0];
  CC[1][2] = C[1][0][2][0];
  CC[1][3] = C[1][0][1][1];
  CC[1][4] = C[1][0][2][1];
  CC[1][5] = C[1][0][2][2];

  CC[2][0] = C[2][0][0][0];
  CC[2][1] = C[2][0][1][0];
  CC[2][2] = C[2][0][2][0] /*/xsi*/;
  CC[2][3] = C[2][0][1][1];
  CC[2][4] = C[2][0][2][1] /*/xsi*/;
  CC[2][5] = C[2][0][2][2];

  CC[3][0] = C[1][1][0][0];
  CC[3][1] = C[1][1][1][0];
  CC[3][2] = C[1][1][2][0];
  CC[3][3] = C[1][1][1][1];
  CC[3][4] = C[1][1][2][1];
  CC[3][5] = C[1][1][2][2];

  CC[4][0] = C[2][1][0][0];
  CC[4][1] = C[2][1][1][0];
  CC[4][2] = C[2][1][2][0] /*/xsi*/;
  CC[4][3] = C[2][1][1][1];
  CC[4][4] = C[2][1][2][1] /*/xsi*/;
  CC[4][5] = C[2][1][2][2];

  CC[5][0] = C[2][2][0][0];
  CC[5][1] = C[2][2][1][0];
  CC[5][2] = C[2][2][2][0];
  CC[5][3] = C[2][2][1][1];
  CC[5][4] = C[2][2][2][1];
  CC[5][5] = C[2][2][2][2];
  /*----------------------------------------------------------------------*/
  return;
} /* end of s8_mat_linel */
/*----------------------------------------------------------------------*
 | PK II stresses                                         m.gee 6/01    |
 *----------------------------------------------------------------------*/
void s8_mat_stress1(DOUBLE *stress, DOUBLE *strain, DOUBLE **C)
{
  DOUBLE E[6];
  /*----------------------------------------------------------------------*/
  E[0] = strain[0];
  E[3] = strain[3];
  E[5] = strain[5];
  E[1] = strain[1] * 2.0;
  E[2] = strain[2] * 2.0;
  E[4] = strain[4] * 2.0;
  math_matvecdense(stress, C, E, 6, 6, 0, 1.0);
  /*----------------------------------------------------------------------*/
  return;
} /* end of s8_mat_linel */
/*----------------------------------------------------------------------*
 | neohooke material from habil wriggers                  m.gee 3/03    |
 *----------------------------------------------------------------------*/
void s8_mat_neohooke(NEO_HOOKE *mat, DOUBLE *stress, DOUBLE **CC, DOUBLE **gmkonr, DOUBLE **gmkonc,
    DOUBLE detr, DOUBLE detc)
{
  INT i, j, k, l;

  /*----- shear correction coefficient not yet introduced */
  /* DOUBLE xsi=1.0; */

  DOUBLE C[3][3][3][3]; /*--------------------------- constitutive tensor */
  DOUBLE sp[3][3];      /*---------------------------------------- PK2 stresses */
  DOUBLE l1, l2;        /*----------------------------------------- lame constants */
  DOUBLE emod, nue;     /*--------------------------------------- mat constants */
  DOUBLE xj;
  DOUBLE F1;
  /*----------------------------------------------------------------------*/
  emod = mat->youngs;
  nue = mat->possionratio;
  l1 = (emod * nue) / ((1.0 + nue) * (1.0 - 2.0 * nue));
  l2 = emod / (2.0 * (1.0 + nue));
  xj = detc / detr;
  if (xj < EPS6) xj = EPS6;
  F1 = l1 * log(xj) - l2;
  /*-------------------------------------------------------- pk2 stresses */
  for (i = 0; i < 3; i++)
    for (j = 0; j < 3; j++) sp[i][j] = F1 * gmkonc[i][j] + l2 * gmkonr[i][j];
  stress[0] = sp[0][0];
  stress[1] = sp[0][1];
  stress[2] = sp[0][2];
  stress[3] = sp[1][1];
  stress[4] = sp[1][2];
  stress[5] = sp[2][2];
  /*---------this is not very fast, but corresponds nicely with theory... */
  for (i = 0; i < 3; i++)
    for (j = 0; j < 3; j++)
      for (k = 0; k < 3; k++)
        for (l = 0; l < 3; l++)
          C[i][j][k][l] = l1 * gmkonc[i][j] * gmkonc[k][l] -
                          F1 * (gmkonc[i][k] * gmkonc[j][l] + gmkonc[i][l] * gmkonc[k][j]);
  /*----------------------------------------------------------------------*/
  CC[0][0] = C[0][0][0][0];
  CC[0][1] = C[0][0][1][0];
  CC[0][2] = C[0][0][2][0];
  CC[0][3] = C[0][0][1][1];
  CC[0][4] = C[0][0][2][1];
  CC[0][5] = C[0][0][2][2];

  CC[1][0] = C[1][0][0][0];
  CC[1][1] = C[1][0][1][0];
  CC[1][2] = C[1][0][2][0];
  CC[1][3] = C[1][0][1][1];
  CC[1][4] = C[1][0][2][1];
  CC[1][5] = C[1][0][2][2];

  CC[2][0] = C[2][0][0][0];
  CC[2][1] = C[2][0][1][0];
  CC[2][2] = C[2][0][2][0] /*/xsi*/;
  CC[2][3] = C[2][0][1][1];
  CC[2][4] = C[2][0][2][1] /*/xsi*/;
  CC[2][5] = C[2][0][2][2];

  CC[3][0] = C[1][1][0][0];
  CC[3][1] = C[1][1][1][0];
  CC[3][2] = C[1][1][2][0];
  CC[3][3] = C[1][1][1][1];
  CC[3][4] = C[1][1][2][1];
  CC[3][5] = C[1][1][2][2];

  CC[4][0] = C[2][1][0][0];
  CC[4][1] = C[2][1][1][0];
  CC[4][2] = C[2][1][2][0] /*/xsi*/;
  CC[4][3] = C[2][1][1][1];
  CC[4][4] = C[2][1][2][1] /*/xsi*/;
  CC[4][5] = C[2][1][2][2];

  CC[5][0] = C[2][2][0][0];
  CC[5][1] = C[2][2][1][0];
  CC[5][2] = C[2][2][2][0];
  CC[5][3] = C[2][2][1][1];
  CC[5][4] = C[2][2][2][1];
  CC[5][5] = C[2][2][2][2];
  /*----------------------------------------------------------------------*/
  return;
} /* end of s8_mat_neohooke */



#endif
