%%
%%############################
\input{def}

%%
%%############################
\chapter{Input parameters}
\label{input_parameters:chap}

It is always hard to write and maintain an accurate reference documentation
for a moving target like \baci{}. The following pages present our best
effort. And please note that \baci{} knows its input file format very
well. You can ask it. Just type
\begin{verbatim}
     ./cca_fc6_lam.debg -d
\end{verbatim}
and you will get a (partial) input file with all the default parameters and
documentation.

%%
%%============================
\section{Overview}

The total input of \ccarat{} is read from formated input files that contain
all data to define a problem. The file is divided in single blocks
by horizontal lines which end with a key word specifying the following
content. There must not be spaces in front of a keyword. An example
is the \kw{PROBLEM TYP} introductory line 
\begin{verbatim}
-------------------------------------------------------PROBLEM TYP
\end{verbatim}
Plenty of keyword lines and blocks refere to special applications
of the program (such as \kw{OPTIMIZATION}, \kw{ALE DYNAMIC} etc.). These often
can be omitted when not required, which shortens the file and eases
its use. Other blocks however are of general character and must not
be left out in order to obtain a valid input file.

The order of the blocks can be chosen arbitrary while a convention
certainly increases comfort. The single blocks are explained in more
detail subsequently. Emphasis is here put on those blocks which are
of general meaning and are used within all kinds of different problem
types. Specific problem dependent blocks such as \kw{ALE SOLVER}, \kw{FLUID
DYNAMIC} or \kw{OPTIMISATION} can be added to this manually as required. 

%%
%%============================
\section{Comments}
Comments start with \kw{//}. These can appear in the first
rows or somewhere else. Everything on their right side is a comment and
neglected. 

%%
%%::::::::::::::::::::::::::::EBNF
\section[EBNF]{Extended Backus--Naur formalism}\label{inparams:sec:ebnf}
An extended Backus--Naur Formalism (EBNF, cf. \cite{inparams:reiser94}), is used to describe the input lines. 

\begin{itemize}
\item Several listed construct are regarded as concatenated:\\
  \kw{C} $=$ \kw{A B} means \kw{C} consists of \kw{A} followed by \kw{B}.
\item Alternatives are separated by \kor{}:\\
  \kw{C} $=$ \kw{A} \kor \kw{B} means \kw{C} $=$ \kw{A} or \kw{C} $=$ \kw{B},
  but not  
  \kw{C} $=$ \kw{A B} or \kw{C} $=$ $\emptyset$\@. 
\item Brackets $[$ and $]$ denote optionality of the enclosed 
  construct:\\
  \kw{B} $=$ $[$\kw{A}$]$ results in \kw{B} $=$ \kw{A} or \kw{B} $=$
  $\emptyset$\@. 
\item Braces $\{$ and $\}$ denote a repetition of a construct, 
  which includes zero repetitions:\\
  \kw{B} $=$ $\{$\kw{A}$\}$ is equivalent to \kw{B} $=
  \emptyset,$\kw{A}$,$\kw{AA}$,$\kw{AAA}$,\ldots$
\item Parentheses $($ and $)$ group expressions.
\item An ellipsis $\ldots$ represents reasonable continuation.
\end{itemize}

%%
%%============================
\section[Input parameters]{List of input parameters}

\subsection{Header}
\begin{verbatim}
==================================================================
                        General Data File CCARAT
==================================================================
\end{verbatim}

\subsection{Title}
\begin{verbatim}
-------------------------------------------------------------TITLE
\end{verbatim}



This block contains the expressive and individual title of your input
problem. 

read in: inpctrhead() in input\_full/input\_ctr\_head.c 

used for: writing it to output file 

written by: hand 


remarks: 

\begin{itemize}
\item The title can be used to set special treatments for selected examples
(which may be advisable for testing only). 
\item The title may be empty or contain up to five lines. 
\item The TITLE head line must not be omitted.
\end{itemize}

\subsection{PROBLEM SIZE}
\begin{verbatim}
------------------------------------------------------PROBLEM SIZE
\end{verbatim}

\kw{ELEMENTS} $int$\\
total number of elements

\kw{NODES} $int$\\
total number of nodes

\kw{DIM} ($2$\kor$3$)\\
DIM number of dimensions (2,3) chosen by gid

\kw{MATERIALS} $int$\\
number of materials assigned

\kw{NUMDF} $int$\\
global estimate of number of DOFs per node

\subsection{PROBLEM TYP}
\begin{verbatim}
-------------------------------------------------------PROBLEM TYP
\end{verbatim}

\kw{PROBLEMTYP} (\kw{Structure}\kor\kw{Fluid_Structure_Interaction}\kor\kw{Fluid}\kor\kw{Optimisation}\kor\kw{Ale})\\
PROBLEMTYP type of calculation

\kw{NUMFIELD} ($1$\kor$2$\kor$3$)\\
NUMFIELD number of fields

\kw{TIMETYP} (\kw{Static}\kor\kw{Dynamic})\\
TIMETYP either dynamic or static calc

\kw{TRACE} (\kw{secure}\kor\kw{fast})\\
TRACE bugtracing support on/off

\kw{ALGEBRA} (\kw{ccarat}\kor\kw{Trilinos})\\
ALGEBRA use ccarat or Trilinos for vectors/matrices etc: (ccarat,Trilinos)

\kw{RESTART} $int$\\
RESTART restart in step number $int$ (0 for initial calculation)

\subsection{DISCRETISATION}
\begin{verbatim}
----------------------------------------------------DISCRETISATION
\end{verbatim}

\kw{NUMFLUIDDIS} $int$\\
Number of fluid discretisations

\kw{NUMSTRUCDIS} $int$\\
Number of structure discretisations

\kw{NUMALEDIS} $int$\\    
Number of ALE discretisations

\kw{NUMTHERMDIS} $int$\\
Number of thermal discretisations

\subsection{IO}
\begin{verbatim}
----------------------------------------------------------------IO
\end{verbatim}

\kw{OUTPUT_OUT} (\kw{Yes}\kor\kw{No})\\
write output in various formats

\kw{OUTPUT_GID} (\kw{Yes}\kor\kw{No})\\
write Gid output data

\kw{OUTPUT_BIN} (\kw{Yes}\kor\kw{No})\\
write BinaryIO output data

\kw{STRUCT_DISP} (\kw{Yes}\kor\kw{No})\\
write displacements

\kw{STRUCT_STRESS} (\kw{Yes}\kor\kw{No})\\
write stresses in structure domain

\kw{STRUCT_STRESS_SMO} (\kw{Yes}\kor\kw{No})\\
write smoothed stresses in structure domain (working/obsolete?)

\kw{STRUCT_SM_DISP} (\kw{Yes}\kor\kw{No})\\
write smoothed displacements in structure domain (working/obsolete?)

\kw{STRUCT_SM_STRESS} (\kw{Yes}\kor\kw{No})\\
write smoothed stresses (?) in structure domain (working/obsolete?)

\kw{FLUID_SOL} (\kw{Yes}\kor\kw{No})\\
write solution in fluid domain: velocities

\kw{FLUID_STRESS} (\kw{Yes}\kor\kw{No})\\
write stresses in fluid domain

\kw{FLUID_VIS} (\kw{Yes}\kor\kw{No})\\
???

\kw{ALE_DISP} (\kw{Yes}\kor\kw{No})\\
write ALE displacements

\kw{THERM_TEMPERATURE} (\kw{Yes}\kor\kw{No})\\
write temperature in thermal domain

\kw{THERM_HEATFLUX} (\kw{Yes}\kor\kw{No})\\
write heat fluxes in thermal domain

\kw{RELATIVE_DISP_NUM}\\
???

\kw{FILESTEPS}\\
???

\kw{PROCESSOR_LOCAL}\\
???

\subsection{STATIC}
\begin{verbatim}
------------------------------------------------------------STATIC
\end{verbatim}
More information in Chapter~\ref{struct_statics:chap}

( \kw{LINEAR} \kor \kw{NONLINEAR} )\\
switch linear or non-linear analysis

The following options apply only in non-linear analysis

\kw{KINTYP XXXXXXXXXXXX}\\
???

\kw{NEWTONRAPHSO} (\kw{Load_Control}\kor\kw{Displacement_Control}\kor\kw{Arc_Control})\\
Control type: load, displacement or arc-length control

\kw{NUMSTEP} $int$\\
number of load steps (pseudo time steps)

\kw{MAXITER} $int$\\
numer of equlibrium iterations

\kw{TOLRESID} $real$\\
iteration tolerance for residuum

\kw{TOLDISP} $real$\\
iteration tolerance forincremental displacements 

\kw{STEPSIZE} $real$\\
???

\kw{IARC} (\kw{Yes}\kor\kw{no})\\
1st type of arc-length method

\kw{ARCSCL} (\kw{0}\kor\kw{1})\\
2nd type of arc-length method

\kw{SIGNCHCSP} (\kw{Yes}\kor\kw{no})\\
current stiffness detection

\kw{RESEVRYDISP} $int$\\
Write displacements every $int$ step 

\kw{RESEVRYSTRS} $int$\\
Write stress every $int$ step

\kw{RESTARTEVRY} $int$\\
Write restart every $int$ step


\subsection{EIGENVALUE ANALYSIS}
\begin{verbatim}
-----------------------------------------------EIGENVALUE ANALYSIS
\end{verbatim}

WARNING: The eigenvalue analysis does not work well. Development will either
be stopped or need tremendous repair works.

\kw{SOLTYP} (\kw{SUBSPACE}\kor\kw{Eignone})\\
Switch Eigenvalue Analysis on/off

\kw{STURM} (\kw{Yes}\kor\kw{No})\\
perform sturm sequence check

\kw{SUBTYP} (\kw{JACOBI}\kor\kw{QZALGO})\\
subspace: Jacobi rotation,  QZ-algorithm

\kw{IFSH} ($0$\kor$1$)\\
flag for shift

\kw{ILMP} (\kw{Yes}\kor\kw{No})\\
lumped mass matrix,  or consistent

\kw{RANGE} (\kw{Yes}\kor\kw{No})\\     
search in a range, or not

\kw{NUMVEC} $int$\\
$int$ number of iteration vectors

\kw{NROOT} $int$\\
number of requested eigenvalues to be converged

\kw{ITEMAX} $int$\\
maximum number of iterations

\kw{IFCTR} (\kw{No}\kor\kw{Screen}\kor\kw{File})\\
output to console/in file

\kw{TOLEIG} $real$\\
tolerance to be used in convergence check

\kw{SHIFT} $real$\\
relative shift (removed after iteration)

\kw{BOULO} $real$\\
lower boundary 

\kw{BOUUP} $real$\\
upper boundary  


\subsection{STRUCTURAL DYNAMIC}
\begin{verbatim}
------------------------------------------------STRUCTURAL DYNAMIC
\end{verbatim}

Please, refer to Report ``Structural dynamics'' (Chapter \ref{strdyn:chap})




\subsection{FLUID DYNAMIC}
\begin{verbatim}
-----------------------------------------------------FLUID DYNAMIC
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Time integration, algorithm:}

\noindent\kw{DYNAMICTYP (}
\begin{tabular}[t]{lc}
\kw{Nlin_Time_Int}                  &{\kor}\\
\kw{Projection_Method or PM_discont}&{\kor}\\
\kw{PM_cont}                        &{\kor}\\
\kw{PM_laplace}                     &\kw{)}
\end{tabular}

Select Projection method (\kw{PM}) or classical time integration

\noindent\kw{TIMEINTEGR (}
\begin{tabular}[t]{lc}
\kw{Stationary}            &{\kor}\\
\kw{One_Step_Theta}        &{\kor}\\
\kw{Gen_Alfa or Gen_Alpha} &{\kor}\\
\kw{BDF2}                  &\kw{)}
\end{tabular}

Selects the time integration algorithm. Remarks:
\begin{center}
\begin{tabular}{l|p{0.3\textwidth}}
\kw{Stationary}            & uses a pseudo time loop \\\hline
\kw{One_Step_Theta}        & 1 step method     \\\hline
\kw{Gen_Alfa or Gen_Alpha} & pressure evaluated at the 
                             intermediate timestep\\\hline
\kw{BDF2}                  & 2 step method, second order  
\end{tabular}
\end{center}

\noindent\kw{NUMSTEP} $int$

Maximum number of timesteps

\noindent\kw{MAXTIME} $real$

Maximum simulation time

\noindent\kw{TIMESTEP} $real$

Time step size

\noindent\kw{THETA} $real$

Parameter for one step theta (and generalized alpha). Remarks:
\begin{itemize}
\item $0.5\leq$\kw{THETA}$\leq1$
\item \kw{THETA}$=0.5$ for one step theta (Crank Nicholson) would be second
order but causes oscillations in practice
\end{itemize}

\noindent\kw{ALPHA_F} $real$

\noindent\kw{ALPHA_M} $real$

Parameters for generalized alpha method. Remarks:
\begin{center}
\begin{tabular}{l|p{0.4\textwidth}}
\kw{ALPHA_F} & force, $0\leq$\kw{ALPHA_F}$\leq1$\\\hline
\kw{ALPHA_M} & momentum, $0\leq$\kw{ALPHA_M}$\leq1$
\end{tabular}
\end{center}

Second order Gen\_Alpha schemes require a certain choice of the parameters!

\noindent\kw{STARTINGALGO (One_Step_Theta)}

Option to start with different time integration scheme. Useful for BDF2. Only
one step theta available.

\noindent\kw{NUMSTASTEPS} $int$

Number of starting algorithm steps

\noindent\kw{START_THETA} $real$

Theta for starting algorithm
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Time integration, check for stationary flows:}
\nopagebreak

\noindent\kw{STEADYCHECK (}
\begin{tabular}[t]{lc}
\kw{No}             &{\kor}\\
\kw{L_infinity_norm}&{\kor}\\
\kw{L_1_norm}       &{\kor}\\
\kw{L_2_norm}       &\kw{)}
\end{tabular}

Norm of time increment for steady state check. Remarks:
\begin{center}
\begin{tabular}{l|p{0.3\textwidth}}
\kw{No}             & don't do anything\\\hline
\kw{L_infinity_norm}& Max. norm\\\hline
\kw{L_1_norm}       & Integral of absolute values\\\hline
\kw{L_2_norm}       & Integral of sqrt of values\^2
\end{tabular}
\end{center}

\noindent\kw{STEADYSTEP} $int$

Steady state check every \kw{STEADYSTEP} steps. $-1$ means no check.

\noindent\kw{STEADYTOL} $real$

Tolerance for steady state check. Choice must depend on \kw{TIMESTEP}!

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Time integration, adaptive:}
\nopagebreak

\noindent\kw{ADAPT_TIME (yes}\kor\kw{no)}

Use adaptive time integration

\noindent\kw{LOC_TRUN_ERR } $real$

Local truncation error for adaptive timestepping

\noindent\kw{MAX_DT} $real$

\noindent\kw{MIN_DT} $real$

Interval for timestep size

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Nonlinear iteration:}
\nopagebreak

\noindent\kw{NONLINITER (}
\begin{tabular}[t]{lc}
\kw{fixed_point_like}&{\kor}\\
\kw{Newton}          &\kw{)}
\end{tabular}

Only for GLS stabilized elements --- for USFEM, Newton is the default!

\noindent\kw{QNEWTON (yes}\kor\kw{no)}
Keep matrix on elements over several steps

\noindent\kw{ITEMAX} $int$

Maximum number of nonlinear iteration steps per timestep. Remark:
\begin{itemize}
\item Algorithm will continue with next timestep, even  if convergence wasn't
achieved!
\end{itemize}

\noindent\kw{CONVCHECK (}
\begin{tabular}[t]{lc}
\kw{No}             &{\kor}\\
\kw{L_infinity_norm}&{\kor}\\
\kw{L_1_norm}       &{\kor}\\
\kw{L_2_norm}       &\kw{)}
\end{tabular}

Norm for convergence check of nonlinear iteration. Increments are 
checked, not the residual!!!
\begin{center}
\begin{tabular}{l|p{0.3\textwidth}}
\kw{No}             & don't do anything\\\hline
\kw{L_infinity_norm}& Max. norm\\\hline
\kw{L_1_norm}       & Integral of absolute values\\\hline
\kw{L_2_norm}       & Integral of sqrt of values\^2
\end{tabular}
\end{center}

\noindent\kw{CONVTOL} $real$

Tolerance for convergence of nonlinear iteration 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{{Simple turbulence models:}}
\nopagebreak

\noindent\kw{TURBULENCE (}
\begin{tabular}[t]{lc}
\kw{No}             &{\kor}\\
\kw{algebraic}      &{\kor}\\
\kw{kappa-eps}      &{\kor}\\
\kw{kappa-omega}    &\kw{)}
\end{tabular}

Use turbulence model to model Reynolds stress tensor.

\noindent\kw{INT_LENGHT} $real$

Internal lenght of problem.

\noindent\kw{ROUGHTNESS} $real$

Roughness of solid boundaries

\noindent\kw{SC_COORD_X} $real$

\noindent\kw{SC_COORD_Y} $real$

Coordinates for scaling the turbulence variables.

\noindent\kw{DISC_CAPT (Yes}\kor\kw{No)}

Discontinuity capturing for turbulence model.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{In-\slash output, restart}
\nopagebreak

\noindent\kw{UPOUT} $int$

Output to .out every \kw{UPOUT} steps --- nodal values and convergence ratios
of nonlinear iteration

\noindent\kw{UPPSS} $int$

Old binary output every \kw{UPPSS} steps

\noindent\kw{UPRES} $int$

Uut to gid every \kw{UPRES} steps

\noindent\kw{RESTARTEVRY} $int$

Write all restart information every \kw{RESTARTEVRY} steps --- this one's
connected to binio \ldots

\noindent\kw{RESSTEP} $int$

restart from step \kw{RESSTEP} if \kw{RESSTEP}$\geq0$
\begin{itemize}
\item This is not the binary io restart
\item Instead, it is connected to read fluid\_start.data
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Free surfaces:}
\nopagebreak

\noindent\kw{FREESURFACE (}
\begin{tabular}[t]{lc}
\kw{no}              &{\kor}\\
\kw{loclag_exp}      &{\kor}\\
\kw{loclag_imp}      &{\kor}\\
\kw{hf_vert_sep}     &{\kor}\\
\kw{hf_vert_imp}     &{\kor}\\
\kw{genfs}           &\kw{)}
\end{tabular}

\noindent\kw{SURFTENSION (yes}\kor\kw{no)}

Include surface tension effects for freesurface.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{ALE related:}
\nopagebreak

\noindent\kw{CHECKAREA (yes}\kor\kw{no)}

Check total area of fluid field.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Analytical solutions, starting solutions:}
\nopagebreak

\noindent\kw{FREESURFACE (}
\begin{tabular}[t]{lc}
\kw{zero_field}        &{\kor}\\
\kw{field_from_file}   &{\kor}\\
\kw{field_by_function} &{\kor}\\
\kw{SOLWAVE}           &{\kor}\\
\kw{WAVEBREAKING}      &{\kor}\\
\kw{BELTRAMI-FLOW}     &{\kor}\\
\kw{KIM-MOIN-FLOW}     &{\kor}\\
\kw{BREAKING-DAM}      &\kw{)}
\end{tabular}

Read\slash set initial field. Remarks:
\begin{center}
\begin{tabular}{l|p{0.6\textwidth}}
\kw{zero_field}        & initialise field to 0 \\\hline
\kw{field_from_file}   & read field from file fluid\_start.data\\\hline
\kw{field_by_function} & using starting function \kw{STARTFUNCNO}\\\hline
\kw{SOLWAVE}           & solitary wave, free surface\\\hline
\kw{WAVEBREAKING}      & wavebreaking problem, free surface\\\hline
\kw{BELTRAMI-FLOW}     & analytical solution used for error calculation\\\hline
\kw{KIM-MOIN-FLOW}     & analytical solution used for error calculation\\\hline
\kw{BREAKING-DAM}      & not available, free surface
\end{tabular}
\end{center}

\noindent\kw{STARTFUNCNO (8}\kor\kw{9)}

\kw{STARTFUNCNO} and \kw{INITIALFILED} set the same integer variable 
\kw{fdyn->init}
\begin{center}
\begin{tabular}[t]{l|l}
\kw{8}        & beltrami\\\hline
\kw{9}        & kim-moin
\end{tabular}
\end{center}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Lift and drag calculation:}
\nopagebreak

\noindent\kw{LIFTDRAG (}
\begin{tabular}[t]{lc}
\kw{yes} or \kw{stress}  &{\kor}\\
\kw{no}                  &{\kor}\\
\kw{nodeforce}           &\kw{)}
\end{tabular}

Activate lift and drag calculation. Remarks:
\begin{center}
\begin{tabular}{l|p{0.6\textwidth}}
\kw{yes} or \kw{stress} & stress calculation in gausspoints, 
                          extrapolation to surface\\\hline
\kw{no}                 & no stress calculation\\\hline
\kw{nodeforce}          & stress calculation by nodal forces
\end{tabular}
\end{center}


\noindent\kw{VISCSTRESS (yes}\kor\kw{no)}

Viscous stresses are included in stress calculation.
             


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Obsolete flags:}
\nopagebreak

\noindent\kw{ALPHA} $real$

\noindent\kw{GAMMA} $real$

\noindent\kw{TIME_RHS (mass}\kor\kw{classic)}

\kw{mass} is the default now!

\noindent\kw{ERRORCAL (yes}\kor\kw{no)}

\noindent\kw{SAVESTEP} $int$

\noindent\kw{SOLVE_FLUID}

\noindent\kw{FLUID_START1} $real$

\noindent\kw{NUMDF} $int$

\noindent\kw{NUMCONT} $int$

\noindent\kw{IPRERHS} $int$



% \kw{DYNAMICTYP *GenData(Fluid_Dynamictype)}\\
% Nonlinear Time Integraton Scheme or Projection Method
% There are the following time integration schemes implemented:
% - One step Theta
% - Generalised Alpha
% - Second order backward differencing (BDF2)


% \kw{INITIALFIELD *GenData(Initial_Starting_Field)}\\
% Initial Starting Field

% \kw{RESSTEP *GenData(Restartstep)}\\
% Restart Step from fluid_start.data if INITIALFIELD=\kw{field_from_file}

% \kw{STARTFUNCNO *GenData(Function_Number)}\\
% Function for Initial Starting Field

% \kw{TIMEINTEGR *GenData(Fluid_Time_Int_Scheme)}\\
% explicit number directly written in the code

% \kw{STARTINGALGO *GenData(Starting_Algo)}\\
% Time Integration Scheme

% \kw{NONLINITER *GenData(Nlin_Iteration)}\\
% Nonlinear iteration scheme

% \kw{ITEMAX *GenData(Max_Nonln_Iterations)}\\
% max. number of nonlin. iterations

% \kw{CONVCHECK *GenData(Convergence_Check)}\\
% norm for convergence check

% \kw{CONVTOL *GenData(Tolerance_Conv_Check)}\\
% Tolerance for convergence check

% \kw{STEADYCHECK *GenData(Steady_State_Check)}\\
% Norm of steady state check

% \kw{STEADYSTEP *GenData(Steady_State_Check_every_Steps)}\\
% steady state check every step

% \kw{STEADYTOL *GenData(Tolerance_Steady_State_Check)}\\
% Tolerance for steady state check

% \kw{UPOUT *GenData(Fluid_Dyn_Sol_to_out_every)}\\
% Increment for writing solution to output file

% \kw{UPPSS *GenData(Fluid_Dyn_Sol_to_pss_every)}\\
% Increment for visualisation via pss-file and VISUAL2

% \kw{UPRES *GenData(Fluid_Dyn_Sol_to_gid_every)}\\
% Increment for writing solution to .flavia.res

% \kw{RESTARTEVRY *GenData(Fluid_Dyn_Restartevry)}\\
% Increment for writing restart to pss file

% \kw{NUMSTEP *GenData(Fluid_Dyn_Num_Steps)  }\\
% Total number of Timesteps

% \kw{NUMSTASTEPS *GenData(Number_of_Starting_Algo_Steps)}\\
% Number of Steps for Starting Scheme

% \kw{MAXTIME *GenData(Fluid_Dyn_Total_Time)}\\
% Total simulation time

% \kw{TIMESTEP *GenData(Fluid_Dyn_Time_Step)  }\\
% Time increment dt

% \kw{MAX_DT *GenData(Fluid_Dyn_Max_Dt)   }\\
% Maximal Time increment dt_max in adaptive case

% \kw{MIN_DT *GenData(Fluid_Dyn_Min_Dt)  }\\
% Minimal Time increment dt_min in adaptive case

% \kw{THETA *GenData(Fluid_Dyn_Theta)}\\
% Time integration factor

% \kw{START_THETA *GenData(Theta_for_Starting_Algo)}\\
% Time integraton factor for starting scheme

% \kw{ALPHA_F *GenData(Fluid_Dyn_Alpha_f)}\\
% Time integration factor

% \kw{ALPHA_M *GenData(Fluid_Dyn_Alpha_m)}\\
% Time integration factor

% \kw{LOC_TRUN_ERR *GenData(Fluid_Dyn_Loc_Trun_Err)}\\
% Local Truncation Error to rule adaptive time stepping

% \kw{VISCSTRESS *GenData(Calculate_visc_stresses)}\\
% when calculating fluid stresses include viscose part

% \kw{FREESURFACE *GenData(Freesurface)}\\
% Treatment of free surface

% \kw{SURFTENSION *GenData(Include_Surfacetension)}\\
% Include surfadce tension effects

% \kw{CHECKAREA *GenData(Fluid_Check_Area)}\\
% Calculate lift and drag forces along specified lines

% \kw{LIFTDRAG *GenData(Fluid_Dyn_Lift_Drag)}\\
% Monitor the size of the fluid domain

% \kw{ADAPT_TIME *GenData(Fluid_Dyn_Adapt_Time)}\\
% Flag, if time stepping is adaptive
% *if(GenData(Commented_Inputfile,int)==1)
% // How to build timerhs?        classic => as described in diss. Wall
% //                              mass    => by means of mass matrix
% *endif
% TIME_RHS     *GenData(Fluid_Dyn_TimeRhs)
% *if(GenData(Commented_Inputfile,int)==1)
% *endif
% TURBULENCE   *GenData(Turbulence_Model)
% *if(GenData(Commented_Inputfile,int)==1)
% *endif
% INT_LENGHT   *GenData(Internal_Lenght)
% *if(GenData(Commented_Inputfile,int)==1)
% *endif
% ROUGHTNESS   *GenData(Roughtness)
% *if(GenData(Commented_Inputfile,int)==1)
% *endif
% SC_COORD_X   *GenData(Scaling_Coord_x)
% *if(GenData(Commented_Inputfile,int)==1)
% *endif
% SC_COORD_Y   *GenData(Scaling_Coord_y)
% *if(GenData(Commented_Inputfile,int)==1)
% *endif
% DISC_CAPT    *GenData(Discontinuity_Capturing_for_Turbulence)
% *if(GenData(Commented_Inputfile,int)==1)
% *endif

\subsection{List/FluidStabilisation}
\begin{verbatim}
-------------------------------------------List/FluidStabilisation
\end{verbatim}
All these input parameters only make sense for the 3d Genalpha
implementation. This part of the input file is directly read into a global
parameterlist and passed on to the genalpha algorithm as a sublist.


\noindent\kw{STABTYPE = residual based VMM}

Since we do not have inf-sup stable elements or other approaches, this is the
only option up to now. 

\noindent\kw{TDS (}
\begin{tabular}[t]{lc}
\kw{= time dependent subscales}  &{\kor}\\
\kw{= quasistatic subscales}     &\kw{)}
\end{tabular}

Select whether quasistatic or time dependent subscales (including history
variables) are selected for the residual based stabilisation.

\noindent\kw{INERTIA (}
\begin{tabular}[t]{lc}
\kw{= keep inertia stabilisation}  &{\kor}\\
\kw{= drop inertia stabilisation}  &\kw{)}
\end{tabular}

If you really want to use time dependent subscales, you should not drop this term.

\noindent\kw{SUPG (}
\begin{tabular}[t]{lc}
\kw{= (svel,(u o nabla)v)}  &{\kor}\\
\kw{= off}                  &\kw{)}
\end{tabular}

Use streamline upwinding or not.

\noindent\kw{PSPG (}
\begin{tabular}[t]{lc}
\kw{= (svel,nabla q)}                 &{\kor}\\
\kw{= inf-sup-stable (off)}           &\kw{)}
\end{tabular}

Pressure stabilisation --- PSPG = off will crash for equal order interpolation!

\noindent\kw{CSTAB (}
\begin{tabular}[t]{lc}
\kw{= (spres,nabla o v)}  &{\kor}\\
\kw{= off}                &\kw{)}
\end{tabular}

Least squares stabilisation of the continuity equation.

\noindent\kw{VSTAB (}
\begin{tabular}[t]{lc}
\kw{= (svel,-2 visc nabla o eps(v))}        &{\kor}\\
\kw{= (svel,+2 visc nabla o eps(v))}        &{\kor}\\
\kw{= (svel,-2 visc nabla o eps(v)) [RHS]}  &{\kor}\\
\kw{= (svel,+2 visc nabla o eps(v)) [RHS]}  &{\kor}\\
\kw{= off}                                  &\kw{)}
\end{tabular}

Viscous stabilisation of GLS+/- type.

\noindent\kw{CROSS-STRESS (}
\begin{tabular}[t]{lc}
\kw{= ((svel o nabla)u,v)}        &{\kor}\\
\kw{= ((svel o nabla)u,v) [RHS]}  &{\kor}\\
\kw{= off}                        &\kw{)}
\end{tabular}

Additional cross-stress expression arising from VMM framework, eventually
useful for turbulence modeling.

\noindent\kw{REYNOLDS-STRESS (}
\begin{tabular}[t]{lc}
\kw{= (svel,(svel o nabla)v) [RHS]}  &{\kor}\\
\kw{= off}                           &\kw{)}
\end{tabular}

Additional reynolds-stress expression arising from VMM framework, eventually
useful for turbulence modeling.
\subsection{List/TurbulenceModel}
All these input parameters only make sense for the 3d Genalpha
implementation. This part of the input file is directly read into a global
parameterlist and passed on to the genalpha algorithm as a sublist.

\begin{verbatim}
----------------------------------------------List/TurbulenceModel
\end{verbatim}

\noindent\kw{TURBULENCE_APPROACH (}
{
\begin{tabular}[t]{lc}
\kw{= none}            &{\kor}\\
\kw{= LES}             &\kw{)}
\end{tabular}
}

The only options available here up to now are LES or none. Open for RANS etc.


\noindent\kw{PHYSICAL_MODEL (}
\begin{tabular}[t]{lc}
\kw{= none}  &{\kor}\\
\kw{= Smagorinsky}                  &{\kor}\\
\kw{= Smagorinsky with van Driest damping}           &\kw{)}
\end{tabular}

Implemented up to now are just LES models like the constant coefficient
Smagorinsky model the Smagorinsky model with Van Driest damping for the
turbulent channel flow. 

\noindent\kw{RE_TAU} = $real$

Reynolds number based on friction velocity and channel half width.

\noindent\kw{L_TAU} = $real$

Viscous lengthscale for application of Van Driest damping (makes sense only
for the turbulent channel flow).

\noindent\kw{C_SMAGORINSKY} = $real$

Smagorinsky constant between 0.1 and 0.24



\subsection{FSI DYNAMIC}
\begin{verbatim}
-------------------------------------------------------FSI DYNAMIC
\end{verbatim}


% \kw{MAXTIME *GenData(FSI_Total_Time)}\\
% Total simulation time

% \kw{TIMESTEP *GenData(FSI_Time_Step)}\\
% Time increment dt

% \kw{NUMSTEP *GenData(FSI_Num_Steps)}\\
% Total number of Timesteps

% \kw{UPPSS *GenData(FSI_Dyn_Sol_to_pss_every)}\\
% Increment for visualisation via pss-file and VISUAL2

% \kw{UPRES *GenData(FSI_Dyn_Sol_to_gid_every)}\\
% Increment for writing solution to .flavia.res

% \kw{RESTARTEVRY *GenData(FSI_Dyn_Restartevry)}\\
% Increment for writing restart to pss file

% \kw{IALE *GenData(FSI_Ale_Field)}\\
% Treatment of ALE-field

% \kw{COUPALGO *GenData(FSI_Coupling_Algorithm)}\\
% Iteration Scheme over the fields

% \kw{PREDICTOR *GenData(FSI_Predictor)}\\
% Predictor for structure field

% \kw{CONVCRIT *GenData(FSI_Conv_Crit)}\\
% Convergence criterium for iteration over fields

% \kw{ENERGYCHECK *GenData(FSI_Energy_Check)}\\
% Energy check for iteration over fields

% \kw{TOLENCHECK *GenData(FSI_Tolerance_Energ_Check)}\\
% Tolerance for energy check

% \kw{RELAX *GenData(FSI_Relax_Param)}\\
% fixed relaxation parameter

% \kw{ITEMAX *GenData(FSI_max_Iter_over_field)}\\
% Maximum number of iterations over fields

% \kw{CONVTOL *GenData(FSI_Tol_Iter_over_field)}\\
% Tolerance for iteration over fields

% \kw{ISDMAX *GenData(FSI_Max_Iter_Steep_Desc)}\\
% not used up to now

% \kw{COUPMETHOD *GenData(FSI_Coup_Method)}\\
% Coupling Method Mortar (mtr) or conforming nodes at interface
% COUPFORCE    *GenData(FSI_Coup_Force)

% \kw{BC_FLUID *GenData(FSI_XFEM_BC_Fluid)}\\
% How to apply Dirichlet BC on discontinuity in fluid elements

\subsection{SSI DYNAMIC}
\begin{verbatim}
-------------------------------------------------------SSI DYNAMIC
\end{verbatim}


% \kw{MAXTIME *GenData(SSI_Total_Time)}\\
% Structure-Structure Interaction Problem maximal simulation time

% \kw{TIMESTEP *GenData(SSI_Time_Step)}\\
% time step size

% \kw{NUMSTEP *GenData(SSI_Num_Steps)}\\
% number of time steps

% \kw{UPPSS *GenData(SSI_Dyn_Sol_to_pss_every)}\\
% Increment for visualisation via pss-file and VISUAL2

% \kw{IALE *GenData(SSI_Ale_Field)}\\
% ALE algorithm

% \kw{COUPALGO *GenData(SSI_Coupling_Algorithm)}\\
% Iteration Scheme over the fields

% \kw{CONVCRIT *GenData(SSI_Conv_Crit)}\\
% Convergence criterium for iteration over fields

% \kw{ENERGYCHECK *GenData(SSI_Energy_Check)}\\
% Energy check for iteration over fields

% \kw{TOLENCHECK *GenData(SSI_Tolerance_Energ_Check)}\\
% Tolerance for energy check

% \kw{RELAX *GenData(SSI_Relax_Param)}\\
% fixed relaxation parameter

% \kw{ITEMAX *GenData(SSI_max_Iter_over_field)}\\
% Maximum number of iterations over fields

% \kw{CONVTOL *GenData(SSI_Tol_Iter_over_field)}\\
% Tolerance for iteration over fields

% \kw{ISDMAX *GenData(SSI_Max_Iter_Steep_Desc)}\\
% not used up to now

% \kw{COUPMETHOD *GenData(SSI_Coup_Method)}\\
% Coupling Method Mortar (mtr) or conforming nodes at interface

\subsection{ALE DYNAMIC}
\begin{verbatim}
-------------------------------------------------------ALE DYNAMIC
\end{verbatim}

% TIMESTEP     *GenData(ALE_Time_Step)
% NUMSTEP      *GenData(ALE_Num_Step)
% MAXTIME      *GenData(ALE_Total_Time)
% NUM_INITSTEP *GenData(ALE_Num_Initstep)
% ALE_TYPE     *GenData(ALE_Typ)
% RESEVRYDISP  *GenData(Write_ale_disp_evry)
% QUALITY      *GenData(ALE_Quality)

\subsection{TSI DYNAMIC}
\begin{verbatim}
-------------------------------------------------------TSI DYNAMIC
\end{verbatim}

\kw{KIND} (\kw{thermal_static_structure_genalpha}\kor\kw{thermal_predefined_structure_dynamic}\kor\kw{thermal_dynamic_structure_dynamic})
type of thermo-structure interaction

\kw{TIMESTEP} $real$\\
time step size

\kw{NUMSTEP} $int$\\
number of time steps

\kw{MAXTIME} $real$\\
final simulation time

\subsection{OPTIMIZATION}
\begin{verbatim}
------------------------------------------------------OPTIMIZATION
\end{verbatim}

WARNING: The eigenvalue analysis does not work well. Development will either
be stopped or ...

\kw{OPT_NUMITER} $int$\\
total number of iteration steps

\kw{OPT_TYPE} (\kw{Topo}\kor\kw{Shape})\\
type of optimization

\kw{OPT_STRATEGY} (\kw{FSD}\kor\kw{NLP})\\
type of optimization strategy

The following sub-options apply only if \kw{OPT_STRATEGY FSD}

\kw{FSD_GRAD} (\kw{Explicit}\kor\kw{Implicit})\\
gradientenbestimmung

\kw{FSD_NUMITER} $int$\\
number of iteration steps with fsd

\kw{FSD_ACC} $real$\\
erforderliche genauigkeit                  

\kw{FSD_ALPHA} $real$\\
genauigkeit fuer die gleichheitsrestriktion

\kw{FSD_BETA} $real$\\
schreitweitenfaktor                        

\kw{FSD_DELTA} $real$\\
schrittweitenbegrenzung                    

\kw{FSD_GAMMA}\\
gleichheitsrestriktionswert                

\kw{OPT_SMO}  (\kw{ON}\kor\kw{OFF})\\
smooth gradients or other values

\kw{SMO_TYPE} (\kw{gradient}\kor\kw{density})\\
???

\kw{SMO_ERAD} $real$\\
radius

\kw{SMO_EXPO} $real$\\
exponent

\kw{OPT_OBJ} (\kw{Stiffness}\kor\kw{Mass})\\
objective

% OV_VAR 1 global opt. variables
%   ELEofMAT 1 TYPE DENS  DL 1.0E-4  DU 1.0E0 SCL 1.
% OV_END
% //
% OC_ICO 0 global inequality constraints
% //
% OC_ECO 1 global   equality constraints
%       DVOLU 1 TYP WEIGHT  SCL 1. 

\subsection{FLUID SOLVER}
\begin{verbatim}
------------------------------------------------------FLUID SOLVER
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Solver}
\noindent\kw{SOLVER (}

\begin{tabular}[t]{lc}
\kw{Aztec_MSR} &{\kor}\\
\kw{SPOOLES_nonsym} &{\kor}\\
\kw{Superlu} &{\kor}\\
\kw{Colsol} &{\kor}\\
\kw{UMFPACK} &{\kor}\\
\kw{Amesos_KLU_sym} &{\kor}\\
\kw{Amesos_KLU_nonsym} &{\kor}\\
\kw{LAPACK_sym} &{\kor}\\
\kw{LAPACK_nonsym} &\kw{)}
\end{tabular}

Available solvers and solver packages.
\begin{center}
\begin{tabular}[t]{l|l}
\kw{Aztec_MSR} &{iterative, parallel}\\\hline
\kw{SPOOLES_nonsym} &{direct, parallel}\\\hline
\kw{Superlu} &{}\\\hline
\kw{Colsol} &{}\\\hline
\kw{UMFPACK} &{direct, serial}\\\hline
\kw{Amesos_KLU_sym} &{}\\\hline
\kw{Amesos_KLU_nonsym} &{default}\\\hline
\kw{LAPACK_sym} &{}\\\hline
\kw{LAPACK_nonsym} &{}
\end{tabular}
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Special AZTEC solver and ML variables}

\noindent\rule{0.5\textwidth}{0.5pt}Aztec-options

\noindent\kw{AZSOLVE (}
\begin{tabular}[t]{lc}
\kw{BiCGSTAB} &{\kor}\\
\kw{CG} &{\kor}\\
\kw{GMRES} &{\kor}\\
\kw{CGS} &{\kor}\\
\kw{LU} &{\kor}\\
\kw{TFQMR} &\kw{)}
\end{tabular}

Available iterative solution algorithms.

\noindent\kw{AZPREC (}
\begin{tabular}[t]{lc}
\kw{none} &{\kor}\\
\kw{ML} &{\kor}\\
\kw{MLFLUID} &{\kor}\\
\kw{MLFLUID2} &{\kor}\\
\kw{ILU} &{\kor}\\
\kw{ILUT} &{\kor}\\
\kw{ICC} &{\kor}\\
\kw{LU} &{\kor}\\
\kw{Jacobi} &{\kor}\\
\kw{SymmGaussSeidel} &{\kor}\\
\kw{Least_Squares} &{\kor}\\
\kw{Neumann} &\kw{)}
\end{tabular}

Available AZTEC preconditioners

\noindent\kw{AZCONV (}
\begin{tabular}[t]{lc}
\kw{AZ_r0             } &{\kor}\\
\kw{AZ_rhs            } &{\kor}\\
\kw{AZ_Anorm          } &{\kor}\\
\kw{AZ_sol            } &{\kor}\\
\kw{AZ_weighted       } &{\kor}\\
\kw{AZ_expected_values} &{\kor}\\
\kw{AZ_noscaled       } &{\kor}\\
\kw{AZTECOO_conv_test } &{\kor}\\
\kw{AZ_inf_noscaled   } &\kw{)}
\end{tabular}

Convergence check for iterative AZTEC solver. Remarks:
\begin{itemize}
\item The default \kw{AZ_noscaled} may be problematic for 
      \kw{FLUID_INCREMENTAL} problems (since the precision is sometimes 
      required for Newton's iteration). Be careful if you use this option
      in combination with this kind of problems!
\item In such cases try for example \kw{AZ_rhs}
\item Detailed explanations in the AZTEC manual
\end{itemize}
\begin{center}
\begin{tabular}[t]{l|l}
\kw{AZ_r0             } &{residual divided by $\|\boldsymbol{r}\|$}\\\hline
\kw{AZ_rhs            } &{residual divided by $\|\boldsymbol{b}\|$}\\\hline
\kw{AZ_Anorm          } &{}\\\hline
\kw{AZ_sol            } &{}\\\hline
\kw{AZ_weighted       } &{}\\\hline
\kw{AZ_expected_values} &{}\\\hline
\kw{AZ_noscaled       } &{default}\\\hline
\kw{AZTECOO_conv_test } &{}\\\hline
\kw{AZ_inf_noscaled   } &{}
\end{tabular}
\end{center}

\noindent\kw{AZTOL} $real$

Tolerance for \kw{AZCONV}-scaled residual required by AZTEC

\noindent\kw{AZITER} $int$

Maximum number of iterations\slash restarts for AZTEC GMRES? 

\noindent\kw{AZSUB} $int$

Dimension of Krylov subspace for AZTEC GMRES.

\noindent\rule{0.5\textwidth}{0.5pt}ML-options

\noindent\kw{ML_PRINT} $int$

ML print-out level (0-10)

\noindent\kw{ML_MAXCOARSESIZE} $int$

ML stop coarsening when coarse ndof smaller then this

\noindent\kw{ML_MAXLEVEL} $int$

ML max number of levels

\noindent\kw{ML_SMOOTHERFINE} $string$

Type of fine grid smoother.

\noindent\kw{ML_SMOOTHERMED} $string$

Type of medium grid smoothers.

\noindent\kw{ML_SMOOTHERCOARSE} $string$

Type of coarse grid solver/smoother.

\noindent\kw{ML_SMOTIMES} $int$(\kw{ML_MAXLEVEL})

For smoothers like SGS: no. smoothing steps or polynomial order on each level (at least \kw{ML_MAXLEVEL} numbers)
For ILU type smoothers: Level of fill

\noindent\kw{ML_DAMPFINE} $double$

Damping on fine grid. Values close to one should be useful for faster convergence, but often 
the value has to be decreased to obtain convergence at all.
For example, some NURBS problems require damping down to 0.3.

\noindent\kw{ML_DAMPMED} $double$

See above.

\noindent\kw{ML_DAMPCOARSE} $double$

See above.

\subsection{STRUCT SOLVER}
\begin{verbatim}
-----------------------------------------------------STRUCT SOLVER
\end{verbatim}

See fluid solver.

\subsection{ALE SOLVER}
\begin{verbatim}
--------------------------------------------------------ALE SOLVER
\end{verbatim}

See fluid solver.

\subsection{THERMAL SOLVER}
\begin{verbatim}
----------------------------------------------------THERMAL SOLVER
\end{verbatim}

See fluid solver.

% SOLVER         *GenData(The_Solver)
% *if(strcmp(GenData(The_Solver),"Aztec_MSR")==0)
% AZSOLVE        *GenData(The_Aztec_Azsol)
% AZPREC         *GenData(The_Aztec_AzPrec)
% AZREUSE        *GenData(The_REUSE)  
% AZDROP         *GenData(The_AZDROP)  
% AZFILL         *GenData(The_DFILL)  
% AZGFILL        *GenData(The_IFILL)  
% AZTOL          *GenData(The_TOL)  
% AZITER         *GenData(The_MAXITER)  
% AZSUB          *GenData(The_AZSUB)  
% AZOMEGA        *GenData(The_AZOMEGA)  
% AZGRAPH        *GenData(The_AZGRAPH)  
% AZPOLY         *GenData(The_AZPOLY)  
% *endif
% *if(strcmp(GenData(The_Solver),"Aztec_VBR")==0)
% AZSOLVE        *GenData(The_Aztec_Azsol)
% AZPREC         *GenData(The_Aztec_AzPrec)
% AZREUSE        *GenData(The_REUSE)  
% AZDROP         *GenData(The_AZDROP)  
% AZFILL         *GenData(The_DFILL)  
% AZGFILL        *GenData(The_IFILL)  
% AZTOL          *GenData(The_TOL)  
% AZITER         *GenData(The_MAXITER)  
% AZSUB          *GenData(The_AZSUB)  
% AZOMEGA        *GenData(The_AZOMEGA)  
% AZGRAPH        *GenData(The_AZGRAPH)  
% AZPOLY         *GenData(The_AZPOLY)  
% *endif
% *if(strcmp(GenData(The_Solver),"HYPRE_BoomerAMG")==0)
% HYPRE_PREC     *GenData(The_HYPRE_Prec)
% HYPRE_IO       *GenData(The_HYPRE_IO)
% HYPRE_ITER     *GenData(The_MAXITER)
% HYPRE_TOL      *GenData(The_TOL)
% HYPRE_THREAS   *GenData(The_AMGThresh)
% HYPRE_SFINE    *GenData(The_AMGnsweepFine)
% HYPRE_SDOWN    *GenData(The_AMGnsweepDown)
% HYPRE_SUP      *GenData(The_AMGnsweepUp)
% HYPRE_SCOARS   *GenData(The_AMGnsweepCoarse)
% *endif
% *if(strcmp(GenData(The_Solver),"HYPRE_PCG")==0)
% HYPRE_PREC     *GenData(The_HYPRE_Prec)
% HYPRE_IO       *GenData(The_HYPRE_IO)
% HYPRE_ITER     *GenData(The_MAXITER)
% HYPRE_TOL      *GenData(The_TOL)
% HYPRE_DFILL    *GenData(The_DFILL) 
% HYPRE_IFILL    *GenData(The_IFILL)  
% HYPRE_PARASY   *GenData(The_Parasymm)
% HYPRE_PARALEV  *GenData(The_Paranlevel)
% HYPRE_PARATHR  *GenData(The_Parathresh)
% HYPRE_PARAFILT *GenData(The_Parafilter)
% HYPRE_THREAS   *GenData(The_AMGThresh)
% HYPRE_SFINE    *GenData(The_AMGnsweepFine)
% HYPRE_SDOWN    *GenData(The_AMGnsweepDown)
% HYPRE_SUP      *GenData(The_AMGnsweepUp)
% HYPRE_SCOARS   *GenData(The_AMGnsweepCoarse)
% *endif
% *if(strcmp(GenData(The_Solver),"HYPRE_GMRES")==0)
% HYPRE_PREC     *GenData(The_HYPRE_Prec)
% HYPRE_IO       *GenData(The_HYPRE_IO)
% HYPRE_ITER     *GenData(The_MAXITER)
% HYPRE_TOL      *GenData(The_TOL)
% HYPRE_KRYDIM   *GenData(The_GMRESKrylovdim)
% HYPRE_DFILL    *GenData(The_DFILL) 
% HYPRE_IFILL    *GenData(The_IFILL)  
% HYPRE_SYMM     *GenData(The_Parasymm)
% HYPRE_PARALEV  *GenData(The_Paranlevel)
% HYPRE_PARATHR  *GenData(The_Parathresh)
% HYPRE_PARAFILT *GenData(The_Parafilter)
% HYPRE_THREAS   *GenData(The_AMGThresh)
% HYPRE_SFINE    *GenData(The_AMGnsweepFine)
% HYPRE_SDOWN    *GenData(The_AMGnsweepDown)
% HYPRE_SUP      *GenData(The_AMGnsweepUp)
% HYPRE_SCOARS   *GenData(The_AMGnsweepCoarse)
% *endif
% *if(strcmp(GenData(The_Solver),"HYPRE_BiCGStab")==0)
% HYPRE_PREC     *GenData(The_HYPRE_Prec)
% HYPRE_IO       *GenData(The_HYPRE_IO)
% HYPRE_ITER     *GenData(The_MAXITER)
% HYPRE_TOL      *GenData(The_TOL)
% HYPRE_DFILL    *GenData(The_DFILL) 
% HYPRE_IFILL    *GenData(The_IFILL)  
% HYPRE_SYMM     *GenData(The_Parasymm)
% HYPRE_PARALEV  *GenData(The_Paranlevel)
% HYPRE_PARATHR  *GenData(The_Parathresh)
% HYPRE_PARAFILT *GenData(The_Parafilter)
% HYPRE_THREAS   *GenData(The_AMGThresh)
% HYPRE_SFINE    *GenData(The_AMGnsweepFine)
% HYPRE_SDOWN    *GenData(The_AMGnsweepDown)
% HYPRE_SUP      *GenData(The_AMGnsweepUp)
% HYPRE_SCOARS   *GenData(The_AMGnsweepCoarse)
% *endif
% *if(strcmp(GenData(The_Solver),"ParSuperLU")==0)
% *endif
% *if(strcmp(GenData(The_Solver),"LAPACK_sym")==0)
% *endif
% *if(strcmp(GenData(The_Solver),"LAPACK_nonsym")==0)
% *endif
% *if(strcmp(GenData(The_Solver),"MUMPS_sym")==0)
% *endif
% *if(strcmp(GenData(The_Solver),"MUMPS_nonsym")==0)
% *endif
% *if(strcmp(GenData(The_Matrix_Format),"OLL")==0)
% MATRIXTYP      *GenData(The_Matrix_Format)
% *endif
% PARTITION      *GenData(Therm_Typ_of_Partitioning)

\subsection{DESIGN DESCRIPTION}
\begin{verbatim}
------------------------------------------------DESIGN DESCRIPTION
NDPOINT W
NDLINE  X
NDSURF  Y
NDVOL   Z
\end{verbatim}

Numbers of design objects used to define the problem. Note that for every
object, the NODE to object topology has to be provided as a 'nodal cloud'.
\subsection{DESIGN POINTS}
\begin{verbatim}
-----------------------------------------------------DESIGN POINTS
\end{verbatim}


% \kw{*tcl(PrintDesignPoints)*\

\subsection{DESIGN LINES}
gid design points written by tcl script

OBSOLETE for baci input, read only in ccarat.

\begin{verbatim}
------------------------------------------------------DESIGN LINES
\end{verbatim}


% \kw{*tcl(PrintDesignLines)*\

\subsection{DESIGN SURFACES}
gid design lines written by tcl script

OBSOLETE for baci input.

\begin{verbatim}
---------------------------------------------------DESIGN SURFACES
\end{verbatim}


% \kw{*tcl(PrintDesignSurfs)*\

\subsection{DESIGN VOLUMES}
gid design surfaces written by tcl script

OBSOLETE for baci input, read only in ccarat.

\begin{verbatim}
----------------------------------------------------DESIGN VOLUMES
\end{verbatim}


% \kw{*tcl(PrintDesignVols)*\

\subsection{DESIGN POINT DIRICH CONDITIONS}
\begin{verbatim}
------------------------------------DESIGN POINT DIRICH CONDITIONS 
DPOINT num
E X - NUMDOF ONOFF(6) VAL(6) CURVE(6) FUNCT(6)
\end{verbatim}
\begin{center}
\begin{tabular}{c||l}
$X$                           & design point id                                                  \\ \hline
NUMDOF                        & Number of DOFs                                                 \\ \hline
ONOFF                          & six (0/1) flags switching the Dirichletboundary condition off/on \\ \hline
VAL                           & six boundary values (double)                                     \\ \hline
CURVE                         & six time-curve ids specifing the corresponding time curves       \\ \hline
FUNCT                         & six function-ids for corresponding spatial functions             \\ 
\end{tabular}
\end{center}

Note:
\begin{itemize}
\item The number of flags, boundary values etc. actually considered in the code depedends on problem type.
\item Functions and curves corresponding to the supplied numbers have to specified seperatly in the 
respective input  section.
\end{itemize}

Example:

\begin{verbatim}
------------------------------------DESIGN POINT DIRICH CONDITIONS 
// DOBJECT FLAG(6) VAL(6) CURVE(6)FUNCT(6)
DPOINT 1
E 9 - 1 1 0 1 0 0 0.0 -1.0 0.0 0.0 0.0 0.0   1   none none none none none 3 2 0 0 0 0
\end{verbatim}

% \kw{// DOBJECT FLAG FLAG FLAG FLAG FLAG FLAG VAL VAL VAL VAL VAL VAL CURVE CURVE CURVE CURVE CURVE CURVE}\\
% point dirich conditions written by tcl script
% *tcl(Dpointdirich)*\

\subsection{DESIGN LINE DIRICH CONDITIONS}
\begin{verbatim}
-------------------------------------DESIGN LINE DIRICH CONDITIONS
\end{verbatim}

See corresponding point condition.
% \kw{// DOBJECT FLAG FLAG FLAG FLAG FLAG FLAG VAL VAL VAL VAL VAL VAL CURVE CURVE CURVE CURVE CURVE CURVE}\\
% line dirich conditions written by tcl script
% *tcl(Dlinedirich)*\

\subsection{DESIGN SURF DIRICH CONDITIONS}
\begin{verbatim}
-------------------------------------DESIGN SURF DIRICH CONDITIONS
\end{verbatim}
See corresponding point condition.

% \kw{// DOBJECT FLAG FLAG FLAG FLAG FLAG FLAG VAL VAL VAL VAL VAL VAL CURVE CURVE CURVE CURVE CURVE CURVE}\\
% surface dirich conditions written by tcl script
% *tcl(Dsurfdirich)*\

\subsection{DESIGN VOL DIRICH CONDITIONS}
\begin{verbatim}
--------------------------------------DESIGN VOL DIRICH CONDITIONS
\end{verbatim}
See corresponding point condition.

% \kw{// DOBJECT FLAG FLAG FLAG FLAG FLAG FLAG VAL VAL VAL VAL VAL VAL CURVE CURVE CURVE CURVE CURVE CURVE}\\
% volume dirich conditions written by tcl script
% *tcl(Dvoldirich)*\

\subsection{DESIGN POINT NEUMANN CONDITIONS}
\begin{verbatim}
-----------------------------------DESIGN POINT NEUMANN CONDITIONS
\end{verbatim}

See corresponding volume condition.

% \kw{// DOBJECT CURVE FLAG FLAG FLAG FLAG FLAG FLAG VAL VAL VAL VAL VAL VAL  NSURF}\\
% point neumann conditions written by tcl script
% *tcl(Dpointneum)*\

\subsection{DESIGN LINE NEUMANN CONDITIONS}
\begin{verbatim}
------------------------------------DESIGN LINE NEUMANN CONDITIONS
\end{verbatim}

See corresponding volume condition.


% \kw{// DOBJECT CURVE FLAG FLAG FLAG FLAG FLAG FLAG VAL VAL VAL VAL VAL VAL  TYPE  NSURF}\\
% line neumann conditions written by tcl script
% *tcl(Dlineneum)*\

\subsection{DESIGN SURF NEUMANN CONDITIONS}
\begin{verbatim}
------------------------------------DESIGN SURF NEUMANN CONDITIONS
\end{verbatim}

See corresponding volume condition.

% \kw{// DOBJECT CURVE FLAG FLAG FLAG FLAG FLAG FLAG VAL VAL VAL VAL VAL VAL  TYPE  NSURF}\\
% surface neumann conditions written by tcl script
% *tcl(Dsurfneum)*\

\subsection{DESIGN VOL NEUMANN CONDITIONS}
\begin{verbatim}
-------------------------------------DESIGN VOL NEUMANN CONDITIONS
E X - NUMDOF ONOFF(6) VAL(6) CURVE(6) FUNCT(6) loadtype
\end{verbatim}

\begin{center}
\begin{tabular}{c||l}
$X$                           & design point id                                                  \\ \hline
NUMDOF                        & Number of DOFs                                                 \\ \hline
ONOFF                         & (0/1) flags switching the boundary condition off/on in the   \\
                              & respective direction                                             \\ \hline
VAL                           & six boundary values (double)                                     \\ \hline
CURVE                         & time-curve ids specifing the corresponding time curve        \\ \hline
FUNCT                         & function-ids for corresponding spatial functions             \\ 
\end{tabular}
\end{center}

\subsection{DESIGN COUPLING POINT CONDITIONS}
\begin{verbatim}
----------------------------------DESIGN COUPLING POINT CONDITIONS
\end{verbatim}


% \kw{// DOBJECT COUPLE_ID FIELD DOFCOUPLE FLAG FLAG FLAG FLAG FLAG FLAG GEOCOUPLE FLAG FLAG FLAG FLAG FLAG FLAG FSICOUPLE}\\
% coupling point conditions written by tcl script
% *tcl(Dcouplepoint)*\

\subsection{DESIGN COUPLING LINE CONDITIONS}
\begin{verbatim}
-----------------------------------DESIGN COUPLING LINE CONDITIONS
\end{verbatim}


% \kw{// DOBJECT COUPLE_ID FIELD DOFCOUPLE FLAG FLAG FLAG FLAG FLAG FLAG GEOCOUPLE FLAG FLAG FLAG FLAG FLAG FLAG FSICOUPLE}\\
% coupling line conditions written by tcl script
% *tcl(Dcoupleline)*\

\subsection{DESIGN COUPLING SURF CONDITIONS}
\begin{verbatim}
-----------------------------------DESIGN COUPLING SURF CONDITIONS
\end{verbatim}


% \kw{// DOBJECT COUPLE_ID FIELD DOFCOUPLE FLAG FLAG FLAG FLAG FLAG FLAG GEOCOUPLE FLAG FLAG FLAG FLAG FLAG FLAG FSICOUPLE}\\
% coupling surface conditions written by tcl script
% *tcl(Dcouplesurf)*\

\subsection{DESIGN COUPLING VOL CONDITIONS}
\begin{verbatim}
------------------------------------DESIGN COUPLING VOL CONDITIONS
\end{verbatim}


% \kw{// DOBJECT COUPLE_ID FIELD DOFCOUPLE FLAG FLAG FLAG FLAG FLAG FLAG GEOCOUPLE FLAG FLAG FLAG FLAG FLAG FLAG FSICOUPLE}\\
% coupling volume conditions written by tcl script
% *tcl(Dcouplevol)*\

\subsection{DESIGN FSI COUPLING LINE CONDITIONS}
\begin{verbatim}
-------------------------------DESIGN FSI COUPLING LINE CONDITIONS
\end{verbatim}

% // DOBJECT FSI_ID FIELD MESH FLAG
% *tcl(DFSIline)*\

\subsection{DESIGN FSI COUPLING SURF CONDITIONS}
\begin{verbatim}
-------------------------------DESIGN FSI COUPLING SURF CONDITIONS
\end{verbatim}

% // DOBJECT FSI_ID FIELD MESH
% *tcl(DFSIsurf)*\

\subsection{DESIGN FSI XFEM COUPLING LINE CONDITIONS}
\begin{verbatim}
--------------------------DESIGN FSI XFEM COUPLING LINE CONDITIONS
\end{verbatim}

% // DOBJECT COUPLING BCFLUID
% *tcl(DFSIXFEMline)*\

\subsection{DESIGN FLUID FREE SURFACE POINT CONDITIONS}
\begin{verbatim}
------------------------DESIGN FLUID FREE SURFACE POINT CONDITIONS
\end{verbatim}

% // DOBJECT
% *tcl(DFreesurfpoint)*\

\subsection{DESIGN FLUID FREE SURFACE LINE CONDITIONS}
\begin{verbatim}
-------------------------DESIGN FLUID FREE SURFACE LINE CONDITIONS
\end{verbatim}

% // DOBJECT
% *tcl(DFreesurfline)*\

\subsection{DESIGN FLUID FREE SURFACE SURF CONDITIONS}
\begin{verbatim}
-------------------------DESIGN FLUID FREE SURFACE SURF CONDITIONS
\end{verbatim}

% // DOBJECT
% *tcl(DFreesurfsurf)*\

\subsection{CONTACT CONDITIONS}
\begin{verbatim}
------------------------------------------------CONTACT CONDITIONS
\end{verbatim}


% \kw{*tcl(Dcontact2D)*\

\subsection{DESIGN AXISHELL THICKNESS LINE CONDITIONS}
contact conditions needed for the wall1  master slave contact (selfcontact not impl.) written by tcl-script
\begin{verbatim}
-------------------------DESIGN AXISHELL THICKNESS LINE CONDITIONS
\end{verbatim}

% *tcl(Dthicknessline)*\

\subsection{DESIGN AXISHELL LOAD LINE CONDITIONS}
\begin{verbatim}
------------------------------DESIGN AXISHELL LOAD LINE CONDITIONS
\end{verbatim}

% *tcl(Daxishellloadline)*\

\subsection{DESIGN AXISHELL COS POINT CONDITIONS}
\begin{verbatim}
------------------------------DESIGN AXISHELL COS POINT CONDITIONS
\end{verbatim}

% *tcl(Daxishellcospoint)*\

\subsection{DESIGN SURFACE CONSERVATIVE OUTFLOW CONSISTENCY}

\begin{verbatim}
--------------------------DESIGN SURFACE CONSERVATIVE OUTFLOW CONSISTENCY
DSURF num
E X -
\end{verbatim}

Required for outflows of conservative fluid implementations with
partially integrated convective term.
No additional parameters but the design surface id.

\subsection{DESIGN SURFACE WEAK DIRICHLET CONDITIONS}
\begin{verbatim}
--------------------------DESIGN SURFACE WEAK DIRICHLET CONDITIONS
DSURF num
E X - gamma-parameter active-components tau_B-definition scaling linearisation \
 bv(x,y,z) CURVE(x,y,z) FUNCT(x,y,z)
\end{verbatim}

\begin{center}
\begin{tabular}{c||l}
$X$                           & design surface id             \\ \hline
gamma-parameter               & apply adjoint viscous term \emph{adjoint-consistent} or \\
                              & \emph{diffusive-optimal}       \\ \hline
active components             & apply weak dbc in \verb1all_directions1 or only 
                                \verb1only_in_normal_direction1 \\ \hline
$\tau_B$-definition           & Definition of $\tau_B$ either \emph{constant} or according to \\
                              & \emph{Spalding}'s law \\ \hline
scaling                       & scaling value (double) for constant $\tau_B$ \\\hline
linearisation                 & include convective inflow term in linearisation (\verb1lin_all1)\\
                              &  or omit it (\verb1no_lin_conv_inflow1)\\\hline
$\left(bv_x,bv_y,bv_z\right)$ & three doubles defining the axis direction \\\hline
CURVE                         & Three curve ids specifing the corresponding time curves \\ \hline
FUNCT                         & Three function ids for corresponding spatial fcts \\ 
\end{tabular}
\end{center}

Example:

\begin{verbatim}
--------------------------DESIGN SURFACE WEAK DIRICHLET CONDITIONS
DSURF 1
E 1 - adjoint-consistent only_in_normal_direction constant 1.0 no_lin_conv_inflow  \
 0.0 0.0 0.0 none none none 0 0 0     
\end{verbatim}

\subsection{DESIGN FLUID LINE LIFT}
\begin{verbatim}
---------------------------------------DESIGN FLUID LINE LIFT&DRAG
\end{verbatim}

See corresponding surface condition.

\subsection{DESIGN FLUID SURF LIFT}
\begin{verbatim}
---------------------------------------DESIGN FLUID SURF LIFT&DRAG
// DOBJECT LIFT_DRAG_ID X_CENTER Y_CENTER Z_CENTER ALE_LINE
E X - ID c_x c_y c_z axis n_x n_y n_z
\end{verbatim}

\begin{center}
\begin{tabular}{c||l}
$X$                        & design surface id \\ \hline
$ID$                       & lift-drag surface id \\ \hline
$\left(c_x,c_y,c_z\right)$ & three doubles defining one point on an axis. The momentum  \\
                           & is computed with respect to this axis. \\\hline
$\left(n_x,n_y,n_z\right)$ & three doubles defining the axis direction \\\hline
\end{tabular}
\end{center}

\subsection{DESIGN FLUID SURFACE STABILISING CONDITIONS}
\begin{verbatim}
-----------------------DESIGN FLUID SURFACE STABILISING CONDITIONS
\end{verbatim}

OBSOLETE in baci, only valid for ccarat!

There are three available stabilisation procedures: GLS, USFEM and TDS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Galerkin Least Squares, old implementation}
\begin{verbatim}
      (1) (2) (3)  (4) (5) (6) (7) (8) (9)      (10)      (11) (12)
E X - GLS yes yes GLS- yes  35 L_2  -1 533 at_center at_center  1.0

The meaning of the single parameters:
 (1) GLS: use Galerkin Least Squares stabilization
 (2) activate advection stabilization (yes/no)
 (3) activate pressure stabilization (yes/no)
     this one is absolutely mandatory because of the LBB condition!!!
 (4) viscous and reactive stabilization: 
     GLS-      : reactive with +1, viscous with +1
     GLS+      : reactive with +1, viscous with -1
     USFEM     : reactive with -1, viscous with -1
     no_GLS    : reactive with +1, no viscous stabilization
     no_USFEM  : reactive with -1, no viscous stabilization
 (5) continuity stabilization (yes or no)
 (6) stabilization parameter for (stationary) instationary case
 (7) norm for velocity used to calculate stabilization parameter
     (L1 or L2)
 (8) mk --- this determines how mk is evaluated --- mk is a parameter
     used during the calculation of the stabilization parameter. It
     is necessary because the inverse estimate for the advection
     diffusion equation (the relation between the norms of the first 
     and second derivatives on an element) depends on the degree of
     the shape functions;
     -1    higher order element diameter (hk) modifications, no 
           changes on mk
      0    no diameter modifications for higher order elements, but
           different mk's for linear and quadratic elements
 (9) How the element length hk should be calculated
             element length for vel stabilization tau[0]
                       |
                       | element length for continuity stabilization tau[2]
                       | |
                       533
                        |
                        element length for pressure stabilization tau[1]

      1    sqrt(area)       \
      2    2*sqrt(area/PI)   | area based hk's
      3    sqrt(2*area/PI)  /
      4    diagonal based hk
      5    streamlength based hk
(10) number of integ. points for streamlength 
     (at_center or every_intpt)
(11) ??????????????????????????????????????
(12) Scaling factor for continuity stabilization terms
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{USFEM}

\begin{verbatim}
E X - USFEM
\end{verbatim}
Galerkin least squares, stabilisation parameter by Franca, Newton linearised elements
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{TDS}
\begin{verbatim}
E X - TDS
\end{verbatim}
Like USFEM with time dependent subscales --- only 2d up to now

\subsection{DESIGN FLUID VOLUME STABILISING CONDITIONS}
\begin{verbatim}
------------------------DESIGN FLUID VOLUME STABILISING CONDITIONS
\end{verbatim}

OBSOLETE in baci, only valid for ccarat!

See \kw{DESIGN FLUID SURFACE STABILISING CONDITIONS}

\subsection{DESIGN POINT LOCSYS CONDITIONS}
\begin{verbatim}
------------------------------------DESIGN POINT LOCSYS CONDITIONS
\end{verbatim}
See corresponding surface condition.

\subsection{DESIGN LINE LOCSYS CONDITIONS}
\begin{verbatim}
-------------------------------------DESIGN LINE LOCSYS CONDITIONS
\end{verbatim}
See corresponding surface condition.

\subsection{DESIGN SURF LOCSYS CONDITIONS}
\begin{verbatim}
-------------------------------------DESIGN SURF LOCSYS CONDITIONS
DSURF NUM
E X - normal n_x n_y n_z tangent t_x t_y t_z origin O_x O_y O_z Type cosytype F_axis F_angle
\end{verbatim}

\begin{center}
\begin{tabular}{c||l}
$X$                        & design surface id \\ \hline
$\left(n_x,n_y,n_z\right)$ & three doubles defininig the cosy's normal vector \\\hline
$\left(t_x,t_y,t_z\right)$ & three doubles defininig the cosy's tangent vector \\\hline
$\left(O_x,O_y,O_z\right)$ & three doubles defininig the cosy's origin \\\hline
cosytype                   & type of coordinate system. Options are: \\
                           & default (rotation of dofs) \\
                           & OriginRadialSliding \\
                           & FunctionEvaluation (used to evaluate functions in local coordinates)\\ \hline
$F_{axis}$                 & int number of a vector valued function defining the \\
                           & axis of rotation for locally rotated local coordinate \\
                           & systems (for example along a circle) \\ \hline
$F_{angle}$                & int number of a scalar valued function defining the \\
                           & angle of rotation for locally rotated local coordinate \\
                           & systems (for example along a circle) \\
\end{tabular}
\end{center}

\subsection{DESIGN VOL LOCSYS CONDITIONS}
\begin{verbatim}
--------------------------------------DESIGN VOL LOCSYS CONDITIONS
\end{verbatim}
See corresponding surface condition.

\subsection{DESIGN LINE PERIODIC BOUNDARY CONDITIONS}

\begin{verbatim}
--------------------------DESIGN LINE PERIODIC BOUNDARY CONDITIONS
\end{verbatim}

Details see corresponding surface condition.

\subsection{DESIGN SURF PERIODIC BOUNDARY CONDITIONS}

\begin{verbatim}
--------------------------DESIGN SURF PERIODIC BOUNDARY CONDITIONS
E X -  ID  MStoggle  PLANE plane LAYER num_layer
\end{verbatim}

\begin{center}
\begin{tabular}{c||l}
$X$            & design surface id of periodic bc                      \\ \hline
$ID$           & the id of the periodic boundary condition this surface\\
               & belongs to                                            \\ \hline
MStoggle       & Master or Slave surface                               \\ \hline
plane          & xy: couple parallel planes, shifted along z-direction \\ 
               & xz: couple parallel planes, shifted along y-direction \\ 
               & yz: couple parallel planes, shifted along x-direction \\ 
               & xyz for coupling of nodes in identical locations.     \\ \hline
$num_{layer}$  & periodic boundary conditions for second order nurbs   \\
               & elements require several layers of control points to  \\
               & couple. This is the layer's ID
\end{tabular}
\end{center}

Remarks:
\begin{itemize}
\item The meshes on corresponding surfaces have to match exactly to be connected. 
\item One Master may have several Slaves (interesting especially for patch 
coupling in a NURBS context)
\end{itemize}

Example (quadratic NURBS mesh, periodic z-direction, several patches):

\begin{verbatim}
--------------------------DESIGN SURF PERIODIC BOUNDARY CONDITIONS
// DOBJECT PBC_ID ORIENTATION
DSURF 6
E 7 -  1 Master  PLANE xyz LAYER 1
E 8 -  1 Slave   PLANE xyz LAYER 1
E 3 -  2 Master  PLANE xy  LAYER 1
E 5 -  2 Slave   PLANE xy  LAYER 1
E 4 -  2 Master  PLANE xy  LAYER 2
E 6 -  2 Slave   PLANE xy  LAYER 2
\end{verbatim}

\subsection{DESIGN SURF MODE FOR KRYLOV SPACE PROJECTION}
See corresponding volume section.

\subsection{DESIGN VOL MODE FOR KRYLOV SPACE PROJECTION}

\begin{verbatim}
-----------------------DESIGN VOL MODE FOR KRYLOV SPACE PROJECTION
DVOL 1
E X - MODE(6) averaging
\end{verbatim}

\begin{center}
\begin{tabular}{c||l}
$X$            & Design surface id of periodic bc                        \\ \hline
MODE           & Six double values defining the mode to be projected out.\\
               & The number of doubles actually read depends on the      \\ 
               & problem type                                            \\ \hline
averaging      & solution average is computed using \verb1integration1 or\\
               & \verb1pointvalues1                                      \\
\end{tabular}
\end{center}

Remarks:
\begin{itemize}
\item For integration based averaging, the elements must implement the
required integration over the shape function.
\item Works only in combination with an iterative Kryloc solver (i.e. with AZTEC)
\end{itemize}

Example:

\begin{verbatim}
-----------------------DESIGN VOL MODE FOR KRYLOV SPACE PROJECTION
DVOL 1
E 1 - 0.0 0.0 0.0 1.0 0.0 0.0 integration
\end{verbatim}


\subsection{DESIGN SURF IMPEDANCE CONDITIONS}

\begin{verbatim}
--------------------------------------------DESIGN SURF IMPEDANCE CONDITIONS
DSURF 2
E 2 - 1 timeperiod 1000 artery termradius 5.0 2.0  -2.253  8.65E-2
E 3 - 2 timeperiod 1000 artery termradius 5.0 2.0  -2.253  8.65E-2
\end{verbatim}

\subsubsection*{Input parameter explanation}
An impedance boundary condition is designed to be used at outflow boundaries of
vessel systems such as the airways or blood vessels. In the current implementation 
one condition (one physical outflow surface) has to be one input line. Consequently
the outflow surface has to be one surface. This is usually the case if you define your
nodal clouds properly.
\par
The parameters after the ``-'' are the following:
\begin{itemize}
\item Integer number, condition Id
\item phrase \texttt{timeperiod} followed by the period lenght given in the time 
      unit used
\item type of boundary condition. Possible strings are
    \begin{itemize}
      \item \texttt{artery}: Olufsen artery tree condition
      \item \texttt{lung}: ask Andrew for details
      \item \texttt{windkessel}: three-parameter windkessel model
    \end{itemize}
\item phrase \texttt{termradius} followed by the terminal radius of the tree given
      in the length unit used.
\end{itemize}
The remaining parameters depend upon the type of boundary condition.
\begin{itemize}
 \item case: Olufsen artery tree model; three parameters defining the compliance
       of the single vessels. These parameters are called $k_1$, $k_2$ and $k_3$
       in~[1]or~[2]. The values that can be found there
       are
       \begin{align*}
        k_1 = 2.0 \times 10^7 \, \frac{\mathrm{g}}{\mathrm{s^2\, cm}} \qquad
        k_2 = -22.53 \,\frac{1}{\mathrm{cm}} \qquad
        k_3 = 8.65 \times 10^5 \, \frac{\mathrm{g}}{\mathrm{s^2\, cm}}
       \end{align*}
       These values have to be fit to the units used!
 \item case: lung model; Parameters are unused and not read
 \item case: windkessel model; three parameters defining the resistances and the
       compliance (capacitance) of the windkessel. Ordered as follows:
       \begin{itemize}
         \item proximal resistance, e.g. $1148\,\frac{\mathrm{g}}{\mathrm{s\, cm^4}}$
         \item distal resistance, e.g. $19352\,\frac{\mathrm{g}}{\mathrm{s\, cm^4}}$
         \item capacitance, e.g. $0.0000366\,\frac{\mathrm{s^2\,cm^4}}{\mathrm{g}}$
       \end{itemize}
       The resistances and the capacitanct have to be adjusted t the respective organ
       or tree and have to be transfered to the unit system used!
\end{itemize}

\paragraph{The idea} behind the different models can be found in [1] and [2] for the artery
tree model while some remarks on the popular windkessel model can for example be taken from [3].
Explanations for the lung impedance model have to be requested from Andrew Comerford.

\paragraph{Current problems} with the present implementation are:
\begin{itemize}
  \item While aparently correct the \texttt{artery} implementation of the Olufsen
        artery tree type of impedance system does rarely give the proper phase 
        shift in the convoluted pressure function over time. Frequently the pressure
        tends to follow the flowrate quite closely. This seems to be due to some 
        unknown `miracle parameters'. Improvements are strongly required!
  \item The \texttt{windkessel} implementation does much better with respect to 
        the pressure but suffers from unknown parameters. It is very hard to guess 
        those somewhat unphysical parameters. In the best case you have some data to 
        fit your parameters to.
  \item A large problem is encountered when more than one outlet has an impedance
        condition assigned. In this case flow from one outlet to the others is 
        observed. This artificial cross-flow oscillates between the outlets while 
        it increases in magnitude until the thing crashes.
        One of the possible reasons seems to be the time lag of the boundary
        pressure.
\end{itemize}

\subsubsection*{References}
%
\begin{tabular}{cl}
$[1]$ & Mette S. Olufsen: Structured tree outflow condition for blood flow in larger
systematic arteries.\\ & \textit{American Physiological Society}, 1999. \\
$[2]$ &
Mette S. Olufsen, Charles S. Peskin, Won Yong Kim, Erik M. Pedersen, Ali Nadim and Jesper Larsen:\\
&Numerical simulation and experimental validation of blood flow in arteries with structured-tree
outflow\\ & conditions. \textit{Annals of Biomedical Engineering} \textbf{28}:1281-1299, 2000. \\
$[3]$ &
Mette S. Olufsen, Ali Nadim and Lewis A. Lipsitz: Dynamics of cerebral blood flow regulation \\
&explained using a lumped parameter model. \textit{Am J Physiol Regulatory Integrative Comp Physiol}\\
&\textbf{282}:R611-R622, 2002.
\end{tabular}


\subsection{DNODE}
\begin{verbatim}
-----------------------------------------------DNODE-NODE TOPOLOGY
\end{verbatim}


% \kw{*Set Cond Design_Node_Number *nodes *CanRepeat}\\
% topology between design nodes and fe-nodes
% *loop nodes *OnlyInCond
% NODE *NodesNum DNODE *cond(Design_Node_Number)
% *end

\subsection{DLINE-NODE TOPOLOGY}
\begin{verbatim}
-----------------------------------------------DLINE-NODE TOPOLOGY
\end{verbatim}


% \kw{*Set Cond Design_Line_Number *nodes *CanRepeat}\\
% topology between design lines and fe-nodes
% *loop nodes *OnlyInCond
% NODE *NodesNum DLINE *cond(Design_Line_Number)
% *end

\subsection{DSURF-NODE TOPOLOGY}
\begin{verbatim}
-----------------------------------------------DSURF-NODE TOPOLOGY
\end{verbatim}


% \kw{*Set Cond Design_Surface_Number *nodes *CanRepeat}\\
% topology between design surfaces and fe-nodes
% *loop nodes *OnlyInCond
% NODE *NodesNum DSURFACE *cond(Design_Surface_Number)
% *end

\subsection{DVOL-NODE TOPOLOGY}
\begin{verbatim}
------------------------------------------------DVOL-NODE TOPOLOGY
\end{verbatim}

% *if(GenData(Commented_Inputfile,int)==1)
% // topology between design volumes and fe-nodes
% *endif
% *Set Cond Design_Volume_Number *nodes *CanRepeat
% *loop nodes *OnlyInCond
% NODE *NodesNum DVOLUME *cond(Design_Volume_Number)
% *end

\subsection{NODE COORDS}
\begin{verbatim}
-------------------------------------------------------NODE COORDS
\end{verbatim}

% *if(GenData(Commented_Inputfile,int)==1)
% // nodal coordinates of the gid-generated mesh
% *endif
% *set elems(all)
% *loop nodes
% *format "  %10i    %20.15e    %20.15e    %20.15e   "
% NODE *NodesNum COORD *NodesCoord(1,real) *NodesCoord(2,real) *NodesCoord(3,real)
% *end nodes

\subsection{ELEMENTS}
\begin{verbatim}
----------------------------------------------------------ELEMENTS
\end{verbatim}


\subsection{STRUCTURE ELEMENTS}
\begin{verbatim}
------------------------------------------------STRUCTURE ELEMENTS
\end{verbatim}

% *Set elems(All)
% *Set elems(Quadrilateral)
% *Set Cond Shell8 *elems *CanRepeat
% *if(GenData(Commented_Inputfile,int)==1)
% //
% // SHELL8 
% //
% // QUAD4 and QUAD9 implemented
% // MAT number of materia law (see materials section of this file)
% // THICK thickness of the shell elements
% // GP number of Gaussian points, integration should be 2x2x2 for QUAD4 and 3x3x2 for QUAD9
% // GP_TRI number of Gaussian points for triangle shell elements (not yet impl.)
% // FORCES coordinate system , the forces will be put out: (XYZ,RST,RST_ortho)
% // EAS parameters for membran,bending,thicknesschange,constantshear,linearsheal
% // ANS (none,Q,T,QT) Q for transvers shear locking, T for curvature thickness locking for quad4 elements (T not yet impl.)
% // recommendation for choice of hybrid parameters for QUAD4 elements:
% // EAS  N4_4 N4_4 N_4 none none ANS  Q
% // SDC scaled director conditioning scaling factor, should be chosen such, that sdc times thickness is equal to average element edge length: (<real>)
% *endif
% *loop elems *OnlyInCond
% *ElemsNum SHELL8 *\
% *if(IsQuadratic ==2) 
% QUAD9 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==1)
% QUAD8 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0)
% QUAD4 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% THICK *cond(Thickness) *\
% GP *cond(nGP_Quad_R) *cond(nGP_Quad_S) *cond(nGP_Quad_T) *\
% GP_TRI *cond(nGP_Tri_R) *\
% FORCES *cond(S8Forces) *\
% EAS  *cond(EAS_E11/E22/E12_const.) *\
% *cond(EAS_E11/E22/E12_lin.) *\
% *cond(EAS_E33_lin) *\
% *cond(EAS_E13/E23_const.) *\
% *cond(EAS_E13/E23_lin.) *\
% ANS  *cond(ANS) *\
% SDC  *cond(SDC) *\

% *end
% *Set elems(All)
% *Set elems(Triangle)
% *Set Cond Shell8 *elems 
% *if(GenData(Commented_Inputfile,int)==1)
% //
% // SHELL8 
% //
% // TRI3 and TRI6 not yet implemented in ccarat
% *endif
% *loop elems *OnlyInCond
% *ElemsNum SHELL8 *\
% *if(*IsQuadratic==1) 
% TRI6 *ElemsConec *\ 
% *else
% TRI3 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% THICK *cond(Thickness) *\
% GP *cond(nGP_Quad_R) *cond(nGP_Quad_S) *cond(nGP_Quad_T) *\
% GP_TRI *cond(nGP_Tri_R) *\
% SYSNORMAL *cond(Sys_normal) *\
% EAS  *cond(EAS_E11/E22/E12_const.) *\
% *cond(EAS_E11/E22/E12_lin.) *\
% *cond(EAS_E33_lin) *\
% *cond(EAS_E13/E23_const.) *\
% *cond(EAS_E13/E23_lin.) *\
% ANS  *cond(ANS) *\
% SDC  *cond(SDC) *\

% //
% // WALL1
% //
% *end
% *Set elems(All)
% *Set elems(Quadrilateral)
% *Set Cond Wall *elems *CanRepeat
% *loop elems *OnlyInCond
% *ElemsNum WALL *\
% *if(IsQuadratic ==2) 
% QUAD9 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==1)
% QUAD8 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0)
% QUAD4 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% THICK *cond(W_Thickness) *\
% GP *cond(nGP_Wall_R) *cond(nGP_Wall_S) *\
% *cond(WallType) *\
% *cond(WallKin) *\
% *cond(WallQ1Model) *\
% STRESSES *cond(Wall_Stresses) *\
% SSI_COUPTYP *cond(Wall_SSI_Coupling_Type) *\
% TSI_COUPTYP *cond(Wall_TSI_Coupling_Type) *\

% *end
% *Set elems(All)
% *Set elems(Triangle)
% *Set Cond Wall *elems *CanRepeat
% *loop elems *OnlyInCond
% *ElemsNum WALL *\
% *if(IsQuadratic ==2) 
% TRI6 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==1)
% TRI6 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0)
% TRI3 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% THICK *cond(W_Thickness) *\
% GP *cond(nGP_Wall_R) *cond(nGP_Wall_S) *\
% *cond(WallType) *\
% *cond(WallKin) *\
% *cond(WallQ1Model) *\
% STRESSES *cond(Wall_Stresses) *\
% SSI_COUPTYP *cond(Wall_SSI_Coupling_Type) *\
% TSI_COUPTYP *cond(Wall_TSI_Coupling_Type) *\

% *end
% *if(GenData(Commented_Inputfile,int)==1)
% //
% // SHELL9  (multilayer shell element)
% //
% // QUAD4, QUAD8 and QUAD9 implemented
% // MAT number of material law (has to be of type MAT_Multilayer)
% //     within MAT_Multilayer, the design of the crossection is defined
% //     -> number of kinematic layers and their heights in percent or total thickness of shell
% //     -> number of material layers, their heights in percent of thickness of adjacent kinematic layer
% //                                   MAT_Id for each layer, rotation angle of Material (if anisotropic)
% //                                   rotation axis 
% // THICK total thickness of the shell elements
% // GP number of Gaussian points, integration should be 2x2x2 for QUAD4 and 3x3x2 for QUAD8/9
% // GP_TRI number of Gaussian points for triangle shell elements (not yet impl.)
% // FORCES coordinate system , the forces will be put out: (XYZ,RST,RST_ortho)
% // EAS parameters for membran,bending,thicknesschange,constantshear,linearshear 
% // ANS (none,Q,T,QT) Q for transvers shear locking (T, QT not yet impl.)
% // SDC scaled director conditioning scaling factor, should be chosen such, that sdc times thickness is equal to average element edge length: (<real>)
% //
% *endif
% *Set elems(All)
% *Set elems(Quadrilateral)
% *Set Cond Shell9 *elems *CanRepeat
% *loop elems *OnlyInCond
% *ElemsNum SHELL9 *\
% *if(IsQuadratic ==2) 
% QUAD9 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==1)
% QUAD8 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0)
% QUAD4 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% THICK *cond(Thickness) *\
% GP *cond(nGP_Quad_R) *cond(nGP_Quad_S) *cond(nGP_Quad_T) *\
% GP_TRI *cond(nGP_Tri_R) *\
% FORCES *cond(S9Forces) *\
% EAS  *cond(EAS_E11/E22/E12_const.) *\
% *cond(EAS_E11/E22/E12_lin.) *\
% *cond(EAS_E33_lin) *\
% *cond(EAS_E13/E23_const.) *\
% *cond(EAS_E13/E23_lin.) *\
% ANS  *cond(ANS) *\
% SDC  *cond(SDC) *\

% *end
% *Set elems(All)
% *Set elems(Triangle)
% *Set Cond Shell9 *elems 
% *if(GenData(Commented_Inputfile,int)==1)
% //
% // SHELL9 
% //
% // TRI3 and TRI6 not yet implemented in ccarat
% //
% *endif
% *loop elems *OnlyInCond
% *ElemsNum SHELL9 *\
% *if(*IsQuadratic==1) 
% TRI6 *ElemsConec *\ 
% *else
% TRI3 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% THICK *cond(Thickness) *\
% GP *cond(nGP_Quad_R) *cond(nGP_Quad_S) *cond(nGP_Quad_T) *\
% GP_TRI *cond(nGP_Tri_R) *\
% FORCES *cond(S9Forces) *\
% EAS  *cond(EAS_E11/E22/E12_const.) *\
% *cond(EAS_E11/E22/E12_lin.) *\
% *cond(EAS_E33_lin) *\
% *cond(EAS_E13/E23_const.) *\
% *cond(EAS_E13/E23_lin.) *\
% ANS  *cond(ANS) *\
% SDC  *cond(SDC) *\


% *end
% *Set elems(All)
% *Set elems(Hexahedra)
% *Set Cond Brick *elems *CanRepeat
% *if(GenData(Commented_Inputfile,int)==1)
% //
% // BRICK1
% //
% *endif
% *loop elems *OnlyInCond
% *ElemsNum BRICK1 *\
% *if(IsQuadratic==2) 
% HEX27 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==1)
% HEX20 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0)
% HEX8 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% GP *\
% *cond(nGP_Hex_R) *\
% *cond(nGP_Hex_S) *\
% *cond(nGP_Hex_T) *\
% GP_TET *\
% *cond(nGP_Tetra_R) *\
% HYB *\
% *cond(BrickHybri) *\
% FORM *\
% *cond(BrickKinem) *\
% STRESSES *\
% *cond(BrickStrIO) *\
% TSI_COUPTYP *\
% *cond(BrickTsiCouptyp) *\

% *end
% *if(GenData(Commented_Inputfile,int)==1)
% // LINE2 (2-noded beam element), LINE3 (3-noded beam element) implemented
% // REF Coordinates of reference node to determine local z-axis
% // MAT Material number of actual beam element
% // AREA area of beam cross section if IKE=1,2 width of beam cross section if IKE=3
% // GS shear correction factor for Timoshenko beam element
% // HEIGHT Height of beam cross section (only used if IKE=3)
% // IYY Moment of Inertia of local y-axis of cross section (only used if IKE=1,2)
% // IZZ Moment of Inertia of local z-axis of cross section (only used if IKE=1,2)
% // IYZ Deviatoric Moment of cross section (only used if IKE=1,2)
% // IT Torsional Moment of Inertia of cross section (only used if IKE=1,2)
% // flag for local element coordinate system
% // LCS = 1 -> local element coordinate system
% // LCS = 0 -> global element coordinate system
% // flag for beam type:
% // IKE = 1 -> Euler Bernoulli beam element
% // IKE = 2 -> Timoshenko beam element with linear kinematic
% // IKE = 3 -> Spatial beam element according to Diss. Weimar
% // GP Number of Gauss Points of actual beam element (only used if IKE=2,3)
% // HC Hinge code for  l o c a l  dofs of actual beam element
% // 0 = fixed
% // 1 = released
% // only valid for beam end nodes
% // node i: ux,uy,uz,phix,phiy,phiz
% // node k: ux,uy,uz,phix,phiy,phiz
% *endif
% *Set elems(All)
% *Set elems(Linear)
% *Set Cond Beam3 *elems *CanRepeat
% *loop elems *OnlyInCond
% *ElemsNum BEAM3 *\
% *if(IsQuadratic==1)
% LINE3 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0)
% LINE2 *ElemsConec *\ 
% *endif
% REF *cond(x_REF) *\
% *cond(y_REF) *\
% *cond(z_REF) *\
% MAT *ElemsMat *\
% AREA *cond(B_A) *\
% GS *cond(B_gs) *\
% HEIGHT *cond(B_h) *\
% IYY *cond(B_Iyy) *\
% IZZ *cond(B_Izz) *\
% IYZ *cond(B_Iyz) *\
% IT *cond(B_IT) *\
% IKE *cond(IKE) *\
% GP *cond(nGP_Beam3) *\
% CODE *cond(ux_i) *\
% *cond(uy_i) *\
% *cond(uz_i) *\
% *cond(phix_i) *\
% *cond(phiy_i) *\
% *cond(phiz_i) *\
% *cond(ux_k) *\
% *cond(uy_k) *\
% *cond(uz_k) *\
% *cond(phix_k) *\
% *cond(phiy_k) *\
% *cond(phiz_k) *\

% *end
% *Set elems(All)
% *Set elems(Tetrahedra)
% *Set Cond Tetrahedra *elems *CanRepeat
% *loop elems *OnlyInCond
% *ElemsNum TETRA1 *\
% *if(*IsQuadratic==1) 
% TET10 *ElemsConec *\ 
% *else
% TET4 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% GP_TET *\
% *cond(nGP_Tet) *\

% *end
% *Set elems(All)
% *Set elems(Linear)
% *Set Cond AxiShell *elems *CanRepeat
% *loop elems *OnlyInCond
% *ElemsNum SAXI *\
% *if(*IsQuadratic==1) 
% LINE3 *ElemsConec *\ 
% *else
% LINE2 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\

% *end
% *Set elems(All)
% *Set elems(Hexahedra)
% *Set Cond Solid3 *elems *CanRepeat
% *if(GenData(Commented_Inputfile,int)==1)
% //
% // SOLID3 hexahedra
% //
% // About:
% //        structural 3dimensional element
% //        classic isoparametric concept
% //        parameter element space has coordinates r,s,t
% //
% // Input parameter:
% // order of shape functions for displacements and geometry
% //        HEX8   tri-linear Lagrangean
% //        HEX20  quadratic serendipity 
% //        HEX27  tri-quadratic Lagrangean
% // Gauss-Legendre integration points 
% //        GP a b c    with
% //           a=1...4  number of Gauss points in r-direction
% //           b=0...4  number of Gauss points in s-direction
% //                    0 is for automatic, i.e. identical to r-direction
% //           c=0...4  number of Gauss points in t-direction
% //                    0 is for automatic, i.e. identical to r-direction
% // spatial kinematics
% //        KINEM Geolin  geometrically linear
% //        KINEM Totlag  geometrically non-linear based on Total
% //                      Lagrangean approach
% // stress output
% //        STRESS None   no stress output (default)
% //        STRESS Gpxyz  materially XYZ-oriented at Gauss points
% //        STRESS Gprst  parametrically rst-oriented at Gauss points
% //                      only rotated! magnitude refers to XYZ-frame
% //        STRESS Gp123  principal stresses and directions at Gauss points
% //        STRESS Ndxyz  materially XYZ-oriented at element nodes
% //        STRESS Ndrst  parametrically rst-oriented at element nodes
% //                      only rotated! magnitude refers to XYZ-frame
% //        STRESS Nd123  principal stresses and directions at element nodes
% *endif
% *loop elems *OnlyInCond
% *ElemsNum SOLID3 *\
% *if(IsQuadratic==2) 
% HEX27 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==1)
% HEX20 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0)
% HEX8 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% GP *\
% *cond(So3_Hex_nGP_R) *\
% *if(strcmp(cond(So3_Hex_nGP_S),"auto")==0)
% 0 *\
% *else
% *cond(So3_Hex_nGP_S) *\
% *endif
% *if(strcmp(cond(So3_Hex_nGP_T),"auto")==0)
% 0 *\
% *else
% *cond(So3_Hex_nGP_T) *\
% *endif
% KINEM *cond(So3_Kinem) *\
% STRESS *cond(So3_StressOut) *\
% TSI_COUPTYP *\
% *cond(So3_TsiCouptyp) *\

% *end
% *Set elems(All)
% *Set elems(Tetrahedra)
% *Set Cond Solid3 *elems *CanRepeat
% *if(GenData(Commented_Inputfile,int)==1)
% //
% // SOLID3 tetrahedra
% //
% // About:
% //        structural 3dimensional element
% //        classic isoparametric concept
% //        parameter element space has coordinates r,s,t
% //
% // Input parameter:
% // order of shape functions for displacements and geometry
% //        HEX8   tri-linear Lagrangean
% //        HEX20  quadratic serendipity 
% //        HEX27  tri-quadratic Lagrangean
% // Gauss-Legendre integration points 
% //        GP a b c        with
% //           a=1,4,5      total number of Gauss points in domain
% //           b=0,1,3,4,6  number of Gauss points on an element face
% //                        0 is for automatic, i.e. fits a
% //           c=0,1,2,3,4  number of Gauss points on an element edge
% //                        0 is for automatic, i.e. fits a
% // spatial kinematics
% //        KINEM Geolin  geometrically linear
% //        KINEM Totlag  geometrically non-linear based on Total
% //                      Lagrangean approach
% // stress output
% //        STRESS None   no stress output (default)
% //        STRESS Gpxyz  materially XYZ-oriented at Gauss points
% //        STRESS Gprst  parametrically rst-oriented at Gauss points
% //                      only rotated! magnitude refers to XYZ-frame
% //        STRESS Gp123  principal stresses and directions at Gauss points
% //        STRESS Ndxyz  materially XYZ-oriented at element nodes
% //        STRESS Ndrst  parametrically rst-oriented at element nodes
% //                      only rotated! magnitude refers to XYZ-frame
% //        STRESS Nd123  principal stresses and directions at element nodes
% *endif
% *loop elems *OnlyInCond
% *ElemsNum SOLID3 *\
% *if(IsQuadratic==1)
% TET10 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0)
% TET4 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% GP *\
% *cond(So3_Tet_nGP_Domain) *\
% *if(strcmp(cond(So3_Tet_nGP_Sides),"auto")==0)
% 0 *\
% *else
% *cond(So3_Tet_nGP_Sides) *\
% *endif
% *if(strcmp(cond(So3_Tet_nGP_Edges),"auto")==0)
% 0 *\
% *else
% *cond(So3_Tet_nGP_Edges) *\
% *endif
% KINEM *cond(So3_Kinem) *\
% STRESS *cond(So3_StressOut) *\
% TSI_COUPTYP *\
% *cond(So3_TsiCouptyp) *\

% *end
% *Set elems(All)

\subsection{FLUID ELEMENTS}
\begin{verbatim}
----------------------------------------------------FLUID ELEMENTS
\end{verbatim}

% *Set elems(All)
% *Set elems(Quadrilateral)
% *Set Cond Fluid2 *elems *CanRepeat
% *loop elems *OnlyInCond
% *if(strcmp(cond(inf-sup_stable),"No")==0) 
% *ElemsNum FLUID2 *\
% *else
% *ElemsNum FLUID2_IS *\
% *endif
% *if(IsQuadratic ==2) 
% QUAD9 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==1)
% QUAD8 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0)
% QUAD4 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% NA *cond(Net_Algo) *\
% GP *cond(nGP_Quad_R) *cond(nGP_Quad_S) *\
% TURBULENCE *cond(Turbulence_Model) *\
% CA *cond(Create_Ale) *\

% *end
% *Set elems(All)
% *Set elems(Triangle)
% *Set Cond Fluid2 *elems *CanRepeat
% *loop elems *OnlyInCond
% *if(strcmp(cond(inf-sup_stable),"No")==0) 
% *ElemsNum FLUID2 *\
% *else
% *ElemsNum FLUID2_IS *\
% *endif
% *if(*IsQuadratic==1) 
% TRI6 *ElemsConec *\ 
% *else
% TRI3 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% NA *cond(Net_Algo) *\
% GP_TRI *cond(nGP_TRI_R) *\
% GP_ALT *cond(TRI_int) *\
% TURBULENCE *cond(Turbulence_Model) *\
% CA *cond(Create_Ale) *\

% *end
% *Set elems(All)
% *Set elems(Hexahedra)
% *Set Cond Fluid3 *elems *CanRepeat
% *loop elems *OnlyInCond
% *if(strcmp(cond(inf-sup_stable),"No")==0) 
% *ElemsNum FLUID3 *\
% *else
% *ElemsNum FLUID3_IS *\
% *endif
% *if(IsQuadratic==2) 
% *format " %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i "
% HEX27 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==1) 
% *format " %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i %5i "
% HEX20 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0) 
% HEX8 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% NA *cond(Net_Algo) *\
% GP *cond(nGP_Hex_R) *cond(nGP_Hex_S) *cond(nGP_Hex_T) *\
% CA *cond(Create_Ale) *\

% *end
% *Set elems(All)
% *Set elems(Tetrahedra)
% *Set Cond Fluid3 *elems *CanRepeat
% *loop elems *OnlyInCond
% *if(strcmp(cond(inf-sup_stable),"No")==0) 
% *ElemsNum FLUID3 *\
% *else
% *ElemsNum FLUID3_IS *\
% *endif
% *if(*IsQuadratic==1) 
% TET10 *ElemsConec *\ 
% *else
% TET4 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% NA *cond(Net_Algo) *\
% GP_TET *\
% *cond(nGP_Tet) *\
% GP_ALT *\
% *cond(TET_int) *\
% CA *cond(Create_Ale) *\

% *end
% *Set elems(All)
% *Set elems(Quadrilateral)
% *Set Cond Fluid2_pro *elems *CanRepeat
% *loop elems *OnlyInCond
% *ElemsNum FLUID2_PRO *\
% *if(*IsQuadratic==1) 
% QUAD9 *ElemsConec *\ 
% *else
% QUAD4 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% NA *cond(Net_Algo) *\
% GP *cond(nGP_Quad_R) *cond(nGP_Quad_S) *\
% DISMODE *cond(Dismode) *\

% *end
% *Set elems(All)

\subsection{ALE ELEMENTS}
\begin{verbatim}
------------------------------------------------------ALE ELEMENTS
\end{verbatim}

% *Set elems(All)
% *Set elems(Hexahedra)
% *Set Cond Ale3 *elems *CanRepeat
% *loop elems *OnlyInCond
% *ElemsNum ALE3 *\
% *if(*IsQuadratic==1) 
% HEX27 *ElemsConec *\ 
% *else
% HEX8 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% GP *\
% *cond(nGP_Hex_R) *\
% *cond(nGP_Hex_S) *\
% *cond(nGP_Hex_T) *\
% JAC *\
% *cond(Jacobi_on/off) *\

% *end
% *Set elems(All)
% *Set elems(Quadrilateral)
% *Set Cond Ale2 *elems *CanRepeat
% *loop elems *OnlyInCond
% *ElemsNum ALE2 *\
% *if(IsQuadratic==2) 
% QUAD9 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==1)
% QUAD8 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0)
% QUAD4 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% GP *\
% *cond(nGP_Hex_R) *\
% *cond(nGP_Hex_S) *\
% JAC *\
% *cond(Jacobi_on/off) *\

% *end
% *Set elems(All)
% *Set elems(Triangle)
% *Set Cond Ale2 *elems *CanRepeat
% *loop elems *OnlyInCond
% *ElemsNum ALE2 *\
% *if(*IsQuadratic==1) 
% TRI6 *ElemsConec *\ 
% *else
% TRI3 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% GP_TRI  *\
% JAC *\
% *cond(Jacobi_on/off) *\

% *end
% *Set elems(All)
% *Set elems(Tetrahedra)
% *Set Cond Ale3 *elems *CanRepeat
% *loop elems *OnlyInCond
% *ElemsNum ALE3 *\
% *if(*IsQuadratic==1) 
% TET10 *ElemsConec *\ 
% *else
% TET4 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% GP_TET *\
% *cond(nGP_Tet) *\
% JAC *\
% *cond(Jacobi_on/off) *\

% *end
% *Set elems(All)

\subsection{THERMAL ELEMENTS}
\begin{verbatim}
--------------------------------------------------THERMAL ELEMENTS
\end{verbatim}

% *Set elems(Quadrilateral)
% *Set Cond Therm2 *elems *CanRepeat
% *if(GenData(Commented_Inputfile,int)==1)
% //
% // THERM2 quadrilaterals
% //
% *endif
% *loop elems *OnlyInCond
% *ElemsNum THERM2 *\
% *if(IsQuadratic==2) 
% QUAD9 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==1)
% QUAD8 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0)
% QUAD4 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% THICK *cond(Th2_Thickness) *\
% GP *cond(nGP_Th2_R) *cond(nGP_Th2_S) *\
% *cond(Th2_Plane_State) *\
% *cond(Th2_Kin) *\
% HFLUX *cond(Th2_Heatflux) *\

% *end
% *Set elems(All)
% *Set elems(Triangle)
% *Set Cond Therm2 *elems *CanRepeat
% *if(GenData(Commented_Inputfile,int)==1)
% //
% // THERM2 triangles
% //
% *endif
% *loop elems *OnlyInCond
% *ElemsNum THERM2 *\
% *if(IsQuadratic==2) 
% TRI6 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==1)
% TRI6 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0)
% TRI3 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% THICK *cond(Th2_Thickness) *\
% GP *cond(nGP_Th2_R) *cond(nGP_Th2_S) *\
% *cond(Th2_Plane_State) *\
% *cond(Th2_Kin) *\
% HFLUX *cond(Th2_Heatflux) *\

% *end
% *Set elems(All)
% *Set elems(Hexahedra)
% *Set Cond Therm3 *elems *CanRepeat
% *if(GenData(Commented_Inputfile,int)==1)
% //
% // THERM3 hexahedra
% //
% *endif
% *loop elems *OnlyInCond
% *ElemsNum THERM3 *\
% *if(IsQuadratic==2) 
% HEX27 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==1)
% HEX20 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0)
% HEX8 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% GP *\
% *cond(Th3_Hex_nGP_R) *\
% *if(strcmp(cond(Th3_Hex_nGP_S),"auto")==0)
% 0 *\
% *else
% *cond(Th3_Hex_nGP_S) *\
% *endif
% *if(strcmp(cond(Th3_Hex_nGP_T),"auto")==0)
% 0 *\
% *else
% *cond(Th3_Hex_nGP_T) *\
% *endif
% KINEM *cond(Th3_Kinem) *\
% HFLUX *cond(Th3_Heatflux) *\

% *end
% *Set elems(All)
% *Set elems(Tetrahedra)
% *if(GenData(Commented_Inputfile,int)==1)
% //
% // THERM3 tetrahedra
% //
% *endif
% *Set Cond Therm3 *elems *CanRepeat
% *loop elems *OnlyInCond
% *ElemsNum THERM3 *\
% *if(IsQuadratic==1)
% TET10 *ElemsConec *\ 
% *endif
% *if(IsQuadratic==0)
% TET4 *ElemsConec *\ 
% *endif
% MAT *ElemsMat *\
% GP *\
% *cond(Th3_Tet_nGP_Domain) *\
% *if(strcmp(cond(Th3_Tet_nGP_Sides),"auto")==0)
% 0 *\
% *else
% *cond(Th3_Tet_nGP_Sides) *\
% *endif
% *if(strcmp(cond(Th3_Tet_nGP_Edges),"auto")==0)
% 0 *\
% *else
% *cond(Th3_Tet_nGP_Edges) *\
% *endif
% KINEM *cond(Th3_Kinem) *\
% HFLUX *cond(Th3_Heatflux) *\

% *end
% *Set elems(All)

\subsection{MATERIALS}
\begin{verbatim}
---------------------------------------------------------MATERIALS
\end{verbatim}

These materials apply only in non-multilayer environments, see below.
Thus we have \kw{MAT_Multilayer}$==0$

More details in Chapter~\ref{struct_mat:chap}.

% *if(strcmp(MatProp(1),"MAT_Struct_StVenantKirchhoff")==0)
% MAT *MatNum *MatProp(1) *\
%  YOUNG *MatProp(Youngs_Modulus) NUE *MatProp(Poisson_Ratio) DENS *MatProp(Density) THEXPANS *MatProp(Thermal_Expansion_Coeff)
% *endif
% linear-elastic st.venant kirchhoff material

% *if(strcmp(MatProp(1),"MAT_Struct_Orthotropic")==0)
% MAT *MatNum *MatProp(1) *\
%  EMOD1 *MatProp(Emod1) EMOD2 *MatProp(Emod2) EMOD3 *MatProp(Emod3) *\
%  GMOD12 *MatProp(Gmod12) GMOD13 *MatProp(Gmod13) GMOD23 *MatProp(Gmod23) *\
%  XNUE12 *MatProp(xnue12) XNUE13 *MatProp(xnue13) XNUE23 *MatProp(xnue23) *\
%  DENS *MatProp(Density)
% *endif
% linear-elastic orthotropic material

% *if(strcmp(MatProp(1),"MAT_fluid")==0)
% MAT *MatNum *MatProp(1) *\
%  VISCOSITY *MatProp(Viscosity) DENSITY *MatProp(Density) GAMMA *MatProp(Gamma)
% *endif

% *if(strcmp(MatProp(1),"MAT_Struct_Ogden")==0)
% MAT *MatNum *MatProp(1) *\
%  NUE *MatProp(NUE) BETA *MatProp(BETA) ALFA1 *MatProp(ALFA1) ALFA2 *MatProp(ALFA2) ALFA3 *MatProp(ALFA3) *\
%  NU1 *MatProp(NU1) NU2 *MatProp(NU2) NU3 *MatProp(NU3) DENS *MatProp(Density)
% *endif
% nonlinear-elastic compressible ogden hyperelastic material (shell8 only);
% see theory (Ogdens Book) to check the parameters, they are simple and clear thenin the shell8 there exist 2 versions of this material, a volumetric-deviatoric coupled and decoupled one

% *if(strcmp(MatProp(1),"MAT_Struct_Viscohyper")==0)
% MAT *MatNum *MatProp(1) *\
%  NUE *MatProp(NUE) BETA *MatProp(BETA) ALFA1 *MatProp(ALFA1) ALFA2 *MatProp(ALFA2) ALFA3 *MatProp(ALFA3) *\
%  NU1 *MatProp(NU1) NU2 *MatProp(NU2) NU3 *MatProp(NU3) DENS *MatProp(Density) *\
%  NMAXW *MatProp(nMaxwells) TAU1 *MatProp(tau1) BETA1 *MatProp(beta1) TAU2 *MatProp(tau2) BETA2 *MatProp(beta2) *\
%  TAU3 *MatProp(tau3) BETA3 *MatProp(beta3) TAU4 *MatProp(tau4) BETA4 *MatProp(beta4)
% *endif
% compressible ogden hyperelastic material (shell8 only);
% see theory (Ogdens Book) to check the parameters, they are simple and clear then;
% inside a generalized maxwell model with upto 4 maxwellelements;
% this is finite LINEAR viscoelasticity following holzapfels book

% *if(strcmp(MatProp(1),"MAT_Struct_NeoHooke")==0)
% MAT *MatNum *MatProp(1) *\
%  YOUNG *MatProp(Youngs_Modulus) NUE *MatProp(Poisson_Ratio) DENS *MatProp(Density)
% *endif
% nonlinear-elastic compressible neo-hooke material (Wriggers' habil)

% *if(strcmp(MatProp(1),"MAT_MisesPlastic")==0)
% MAT *MatNum *MatProp(1) *\
%  YOUNG *MatProp(Youngs_Modulus) NUE *MatProp(Poisson_Ratio) Sigy *MatProp(Yield_Stress) *\
%  BETAH *MatProp(BetaH_kin_iso) DENS *MatProp(Density) *\
% *if(strcmp(MatProp(HardSoft),"Hardening")==0)
%    Hard *MatProp((Hardening)Hard)
% *endif
% *if(strcmp(MatProp(HardSoft),"Softening")==0)
%    GF   *MatProp((Softening)GF)
% *endif
% *endif
% von Mises Plasticity with linear hardening/softening (2D-formulated)

% *if(strcmp(MatProp(1),"MAT_3DMisesPlastic")==0)
% MAT *MatNum *MatProp(1) *\
%  YOUNG *MatProp(Youngs_Modulus) NUE *MatProp(Poisson_Ratio) Sigy *MatProp(Yield_Stress) *\
%  BETAH *MatProp(BetaH_kin_iso) DENS *MatProp(Density) *\
% *if(strcmp(MatProp(HardSoft),"Hardening")==0)
%    Hard *MatProp((Hardening)Hard)
% *endif
% *if(strcmp(MatProp(HardSoft),"Softening")==0)
%    GF   *MatProp((Softening)GF)
% *endif
% *endif
% von Mises Plasticity with linear hardening/softening (3D-formulated)

% *if(strcmp(MatProp(1),"MAT_3DConcretePlastic")==0)
% MAT *MatNum *MatProp(1) *\
%  YOUNG *MatProp(YOUNG) NUE  *MatProp(NUE)  FTM *MatProp(FTM)  FCM *MatProp(FCM) *\
%  GT *MatProp(GT) GC *MatProp(GC)  GAMMA1 *MatProp(GAMMA1)  GAMMA2 *MatProp(GAMMA2) *\
%  GAMMA3 *MatProp(GAMMA3)  GAMMA4 *MatProp(GAMMA4)  DENS *MatProp(Density)
% *endif
% Elasto-Plastic material Modell (Menrath) (3D-formulated)

% *if(strcmp(MatProp(1),"MAT_Therm_Fourier_iso")==0)
% MAT *MatNum *MatProp(1) *\
%  CONDUCT *MatProp(Conduct)
% *endif
% isotropic Fourier law

% *if(strcmp(MatProp(1),"MAT_Therm_Fourier_gen")==0)
% MAT *MatNum *MatProp(1) *\
%  CONDUCT *MatProp(Conduct_11) *MatProp(Conduct_12) *MatProp(Conduct_13) *\
%  *MatProp(Conduct_21) *MatProp(Conduct_22) *MatProp(Conduct_23) *\
%  *MatProp(Conduct_31) *MatProp(Conduct_32) *MatProp(Conduct_33)
% *endif
% general Fourier law

% *if(strcmp(MatProp(1),"MAT_Multilayer")==0)
% MAT *MatNum *MatProp(1) *\
%  NUM_KLAY *MatProp(Num_KLay,int) SEC_KLAY *MatProp(SEC_Klay)
% *if(MatProp(Num_KLay,int)>0)
%      KINLAY 1 NUM_MLAY *MatProp(Num_MLay1) *\
%  SEC_MLAY  *MatProp(SEC_MLay1)  SEC_MAT  *MatProp(SEC_Mat1) *\
%  SEC_PHI  *MatProp(SEC_Phi1)  SEC_ROT  *MatProp(SEC_Rot1)
% *endif

% *if(MatProp(Num_KLay,int)>1)
%      KINLAY 2 NUM_MLAY *MatProp(Num_MLay2) *\
%  SEC_MLAY  *MatProp(SEC_MLay2)  SEC_MAT  *MatProp(SEC_Mat2) *\
%  SEC_PHI  *MatProp(SEC_Phi2)  SEC_ROT  *MatProp(SEC_Rot2)
% *endif
% *endif
% *end
% ???

\subsection{MULTILAYER MATERIALS}
\begin{verbatim}
----------------------------------------------MULTILAYER MATERIALS
\end{verbatim}

MULTILAYER MATERIALS, only used for shell9 elements, in order to define
different materials for one element (design surface),
conditions that are similar to the materials used for single layer elements

% *endif
% *Set elems(All)
% *Set Cond MultiMat1 *elems *CanRepeat
% *loop elems *OnlyInCond
% *if(LoopVar==1)
% MULTIMAT 1  *cond(MatType1) *\
% *if(strcmp(cond(MatType1),"MAT_Struct_StVenantKirchhoff")==0)
%  YOUNG *cond(Youngs_Modulus_1) NUE *cond(Poisson_Ratio_1) DENS *cond(Density_stv1)
% *endif
% *if(strcmp(cond(MatType1),"MAT_Struct_Orthotropic")==0)
%  EMOD1 *cond(Emod1_1) EMOD2 *cond(Emod2_1) EMOD3 *cond(Emod3_1)*\
%  GMOD12 *cond(Gmod12_1) GMOD13 *cond(Gmod13_1) GMOD23 *cond(Gmod23_1)*\
%  XNUE12 *cond(Xnue12_1) XNUE13 *cond(Xnue13_1) XNUE23 *cond(Xnue23_1) DENS *cond(Density_orth1)
% *endif
% *if(strcmp(cond(MatType1),"MAT_MisesPlastic")==0)
%  YOUNG *cond(YOUNG_mis1)  NUE  *cond(NUE_mis1)  Sigy *cond(Sigy_mis1)*\
%  BETAH *cond(betah_mis1)  DENS *cond(Density_mis1) *\
% *if(strcmp(cond(HardSoftMis1),"Hardening")==0)
%    Hard *cond((Hardening)Hard_mis1)
% *endif
% *if(strcmp(cond(HardSoftMis1),"Softening")==0)
%    GF   *cond((Softening)GF_mis1)
% *endif
% *endif
% *if(strcmp(cond(MatType1),"MAT_DP_Plastic")==0)
%  YOUNG *cond(YOUNG_dp1) NUE  *cond(NUE_dp1)  Sigy *cond(Sigy_dp1)*\
%  BETAH *cond(betah_dp1) PHI *cond(PHI_dp1)  DENS *cond(Density_dp1) *\
% *if(strcmp(cond(HardSoftDP1),"Hardening")==0)
%    Hard *cond((Hardening)Hard_dp1)
% *endif
% *if(strcmp(cond(HardSoftDP1),"Softening")==0)
%    GF   *cond((Softening)GF_dp1)
% *endif
% *endif
% *if(strcmp(cond(MatType1),"MAT_HoffPlastic")==0)
%  EMOD1  *cond(E1_1) EMOD2  *cond(E2_1) EMOD3  *cond(E3_1) *\
%  GMOD12 *cond(GM12_1) GMOD23 *cond(GM23_1) GMOD13 *cond(GM13_1) *\
%  XNUE12 *cond(NU12_1) XNUE23 *cond(NU23_1) XNUE13 *cond(NU13_1) UNIAX *cond(UNIAX_1) DENS *cond(Density_hoff1)
%  S11T  *cond(S11T_1) S11C  *cond(S11C_1) S22T  *cond(S22T_1) S22C  *cond(S22C_1)*\
%  S33T  *cond(S33T_1) S33C  *cond(S33C_1) S12  *cond(S12_1) S23  *cond(S23_1) S13  *cond(S13_1)
%  SH11T *cond(SH11T_1) SH11C *cond(SH11C_1) SH22T *cond(SH22T_1) SH22C *cond(SH22C_1)*\
%  SH33T *cond(SH33T_1) SH33C *cond(SH33C_1) SH12 *cond(SH12_1) SH23 *cond(SH23_1) SH13 *cond(SH13_1)
%  HA11T *cond(HA11T_1) HA11C *cond(HA11C_1) HA22T *cond(HA22T_1) HA22C *cond(HA22C_1)*\
%  HA33T *cond(HA33T_1) HA33C *cond(HA33C_1) HA12 *cond(HA12_1) HA23 *cond(HA23_1) HA13 *cond(HA13_1)
% *endif
% *if(strcmp(cond(MatType1),"MAT_ConcretePlastic")==0)
%  YOUNG *cond(YOUNG_epc1) NUE  *cond(NUE_epc1)  FTM *cond(FTM_epc1)  FCM *cond(FCM_epc1) *\
%  GT *cond(GT_epc1) GC *cond(GC_epc1)  GAMMA1 *cond(GAMMA1_epc1)  GAMMA2 *cond(GAMMA2_epc1) *\
%  GAMMA3 *cond(GAMMA3_epc1)  GAMMA4 *cond(GAMMA4_epc1)  DENS *cond(Density_epc1)
% *endif
% *endif
% *end
% *Set Cond MultiMat2 *elems *CanRepeat
% *loop elems *OnlyInCond
% *if(LoopVar==1)
% MULTIMAT 2  *cond(MatType2) *\
% *if(strcmp(cond(MatType2),"MAT_Struct_StVenantKirchhoff")==0)
%  YOUNG *cond(Youngs_Modulus_2) NUE *cond(Poisson_Ratio_2) DENS *cond(Density_stv2)
% *endif
% *if(strcmp(cond(MatType2),"MAT_Struct_Orthotropic")==0)
%  EMOD1 *cond(Emod1_2) EMOD2 *cond(Emod2_2) EMOD3 *cond(Emod3_2)*\
%  GMOD12 *cond(Gmod12_2) GMOD13 *cond(Gmod13_2) GMOD23 *cond(Gmod23_2)*\
%  XNUE12 *cond(Xnue12_2) XNUE13 *cond(Xnue13_2) XNUE23 *cond(Xnue23_2) DENS *cond(Density_orth2)
% *endif
% *if(strcmp(cond(MatType2),"MAT_MisesPlastic")==0)
%  YOUNG *cond(YOUNG_mis2) NUE  *cond(NUE_mis2)  Sigy *cond(Sigy_mis2)*\
%  BETAH *cond(betah_mis2)  DENS *cond(Density_mis2) *\
% *if(strcmp(cond(HardSoftMis2),"Hardening")==0)
%    Hard *cond((Hardening)Hard_mis2)
% *endif
% *if(strcmp(cond(HardSoftMis2),"Softening")==0)
%    GF   *cond((Softening)GF_mis2)
% *endif
% *endif
% *if(strcmp(cond(MatType2),"MAT_DP_Plastic")==0)
%  YOUNG *cond(YOUNG_dp2) NUE  *cond(NUE_dp2)  Sigy *cond(Sigy_dp2)*\
%  BETAH *cond(betah_dp2) PHI *cond(PHI_dp2)  DENS *cond(Density_dp2) *\
% *if(strcmp(cond(HardSoftDP2),"Hardening")==0)
%    Hard *cond((Hardening)Hard_dp2)
% *endif
% *if(strcmp(cond(HardSoftDP2),"Softening")==0)
%    GF   *cond((Softening)GF_dp2)
% *endif
% *endif
% *if(strcmp(cond(MatType2),"MAT_HoffPlastic")==0)
%  EMOD1  *cond(E1_2) EMOD2  *cond(E2_2) EMOD3  *cond(E3_2) *\
%  GMOD12 *cond(GM12_2) GMOD23 *cond(GM23_2) GMOD13 *cond(GM13_2) *\
%  XNUE12 *cond(NU12_2) XNUE23 *cond(NU23_2) XNUE13 *cond(NU13_2) UNIAX *cond(UNIAX_2) DENS *cond(Density_hoff2)
%  S11T  *cond(S11T_2) S11C  *cond(S11C_2) S22T  *cond(S22T_2) S22C  *cond(S22C_2)*\
%  S33T  *cond(S33T_2) S33C  *cond(S33C_2) S12  *cond(S12_2) S23  *cond(S23_2) S13  *cond(S13_2)
%  SH11T *cond(SH11T_2) SH11C *cond(SH11C_2) SH22T *cond(SH22T_2) SH22C *cond(SH22C_2)*\
%  SH33T *cond(SH33T_2) SH33C *cond(SH33C_2) SH12 *cond(SH12_2) SH23 *cond(SH23_2) SH13 *cond(SH13_2)
%  HA11T *cond(HA11T_2) HA11C *cond(HA11C_2) HA22T *cond(HA22T_2) HA22C *cond(HA22C_2)*\
%  HA33T *cond(HA33T_2) HA33C *cond(HA33C_2) HA12 *cond(HA12_2) HA23 *cond(HA23_2) HA13 *cond(HA13_2)
% *endif
% *if(strcmp(cond(MatType2),"MAT_ConcretePlastic")==0)
%  YOUNG *cond(YOUNG_epc2) NUE  *cond(NUE_epc2)  FTM *cond(FTM_epc2)  FCM *cond(FCM_epc2) *\
%  GT *cond(GT_epc2) GC *cond(GC_epc2)  GAMMA1 *cond(GAMMA1_epc2)  GAMMA2 *cond(GAMMA2_epc2) *\
%  GAMMA3 *cond(GAMMA3_epc2)  GAMMA4 *cond(GAMMA4_epc2)  DENS *cond(Density_epc2)
% *endif
% *endif
% *end

\subsection{CONTROL NODE}
\begin{verbatim}
------------------------------------------------------CONTROL NODE
\end{verbatim}

\kw{NODE} $int_1$ \kw{DOF} $int_2$\\
controlled NODE $int_1$ with $int_2$ the DOF to control

\subsection{LOAD CURVES}
\begin{verbatim}
-------------------------------------------------------LOAD CURVES
\end{verbatim}


\subsection{CURVE1}
\begin{verbatim}
------------------------------------------------------------CURVE1
\end{verbatim}
Beside several special scenarios there are basically three different ways to define a time-dependent curve:

\begin{itemize}
 \item Define a polygonal curve (linear interpolation between to values):
\begin{verbatim}
CURVE %ID on Polygonal T 1.0 BYABSTIME Yes %t_start %t_end FACTOR %value1 %value2
\end{verbatim}
whereat \%ID specifies the curve id. The value is then determined by linear interpolation with regard to t\_start and t\_end according to
\begin{equation}
 val(t) = \%value1 + \frac{\%value2 - \%value1}{\%t\_end - \%t\_start} \cdot \left(t - \%t\_begin \right) .
\end{equation}

If somebody does know what the ``T'' (and probably the mandatory following double parameter) is good for, well I don't...

\item Specify a time curve by a user-defined expression:
\begin{verbatim}
CURVE %ID on EXPR FUNC %expr t1 %t_start t2 %t_end
\end{verbatim}
In this case \%expr is an expression composed out of basic operations and functions where the character ``t'' is to be used
as the free variable. For a list of possible functions see FUNC1. \%t\_start and \%t\_end are the bounds of the time interval in which
the curve is defined.\\

For a piecewise defined curve add multiple entries with identical id for each time interval.

\item Use a hard-coded time curve:\\
Within baci several curves are hard-coded (to save parsing time?). The syntax is
\begin{verbatim}
CURVE %ID on Explicit FUNC %func c1 %c1_val c2 %c2_val
\end{verbatim}
whereat \%c1\_val and \%c2\_val are used as parameters for the specified curve. The curve itself is defined by
the string \%func which should be one of those: \\
\begin{tabular}{ccc}
\verb|f(t)=sin(t:C1*PI:2)_for_t<_C1_else_f(t)=1 | &
\verb|f(t)=exp(1-1:t)_for_t<C1_else_const | \\
\verb|f(t)=1-cos(2*PI*C1*t) | &
\verb|f(t)=C2*sin(2PI*C1*t) |\\
\verb|f(t)=(sin(PI(t:C1-0.5))+1)*0.5 |&
\verb|BELTRAMI |\\
\verb|KIM-MOIN |&
\verb|f(t)=(C2:2PI*C1)*cos(2PI*C1*t) |\\
\verb|f(t)=t:2-C1:(2PI)*cos(PI*t:C1-PI:2) |&
\verb|f(t)=-0.5*cos(PI*(T-C1)/C2)+0.5 |\\
\verb|f(t)=(1-C2/C1)*T+C2 | 
\end{tabular} \\
(At least as long as you don't like error messages)






\end{itemize}


% *loop intervals
% *if(strcmp(IntvData(Load_Curve_1),"on")==0)
% CURVE1 *IntvData(Load_Curve_1) *\
% *if(strcmp(IntvData(Typ_Curve_1),"Polygonal")==0)
% *IntvData(Typ_Curve_1) *\
% T *IntvData(Cu1_Streamtime) *\
% BYABSTIME *IntvData(Cu1_By_Absolut_Time) *\
% *IntvData(Cu1_Time_Start) *\
% *IntvData(Cu1_Time_End) *\
% FACTOR *IntvData(Cu1_Factor_Start) *\
% *IntvData(Cu1_Factor_End)
% *endif
% *if(strcmp(IntvData(Typ_Curve_1),"Explicit")==0)
% *IntvData(Typ_Curve_1) *\
% FUNC *IntvData(Cu1_Function) *\
% c1 *IntvData(Cu1_C1) *\
% c2 *IntvData(Cu1_C2)
% *endif
% *if(strcmp(IntvData(Typ_Curve_1),"EXPR")==0)
% EXPR FUNC *IntvData(Cu1_expression) *\
% t1 *IntvData(Cu1_Time_Start) *\
% t2 *IntvData(Cu1_Time_End)
% *endif
% *endif
% *end

\subsection{CURVE2}
\begin{verbatim}
------------------------------------------------------------CURVE2
\end{verbatim}

% *loop intervals
% *if(strcmp(IntvData(Load_Curve_2),"on")==0)
% CURVE2 *IntvData(Load_Curve_2) *\
% *if(strcmp(IntvData(Typ_Curve_2),"Polygonal")==0)
% *IntvData(Typ_Curve_2) *\
% T *IntvData(Cu2_Streamtime) *\
% BYABSTIME *IntvData(Cu2_By_Absolut_Time) *\
% *IntvData(Cu2_Time_Start) *\
% *IntvData(Cu2_Time_End) *\
% FACTOR *IntvData(Cu2_Factor_Start) *\
% *IntvData(Cu2_Factor_End)
% *endif
% *if(strcmp(IntvData(Typ_Curve_2),"Explicit")==0)
% *IntvData(Typ_Curve_2) *\
% FUNC *IntvData(Cu2_Function) *\
% c1 *IntvData(Cu2_C1) *\
% c2 *IntvData(Cu2_C2)
% *endif
% *if(strcmp(IntvData(Typ_Curve_2),"EXPR")==0)
% EXPR FUNC *IntvData(Cu2_expression) *\
% t1 *IntvData(Cu2_Time_Start) *\
% t2 *IntvData(Cu2_Time_End)
% *endif
% *endif
% *end

\subsection{CURVE3}
\begin{verbatim}
------------------------------------------------------------CURVE3
\end{verbatim}

% *loop intervals
% *if(strcmp(IntvData(Load_Curve_3),"on")==0)
% CURVE3 *IntvData(Load_Curve_3) *\
% *if(strcmp(IntvData(Typ_Curve_3),"Polygonal")==0)
% *IntvData(Typ_Curve_3) *\
% T *IntvData(Cu3_Streamtime) *\
% BYABSTIME *IntvData(Cu3_By_Absolut_Time) *\
% *IntvData(Cu3_Time_Start) *\
% *IntvData(Cu3_Time_End) *\
% FACTOR *IntvData(Cu3_Factor_Start) *\
% *IntvData(Cu3_Factor_End)
% *endif
% *if(strcmp(IntvData(Typ_Curve_3),"Explicit")==0)
% *IntvData(Typ_Curve_3) *\
% FUNC *IntvData(Cu3_Function) *\
% c1 *IntvData(Cu3_C1) *\
% c2 *IntvData(Cu3_C2)
% *endif
% *if(strcmp(IntvData(Typ_Curve_3),"EXPR")==0)
% EXPR FUNC *IntvData(Cu3_expression) *\
% t1 *IntvData(Cu3_Time_Start) *\
% t2 *IntvData(Cu3_Time_End)
% *endif
% *endif
% *end

\subsection{CURVE4}
\begin{verbatim}
------------------------------------------------------------CURVE4
\end{verbatim}

% *loop intervals
% *if(strcmp(IntvData(Load_Curve_4),"on")==0)
% CURVE4 *IntvData(Load_Curve_4) *\
% *if(strcmp(IntvData(Typ_Curve_4),"Polygonal")==0)
% *IntvData(Typ_Curve_4) *\
% T *IntvData(Cu4_Streamtime) *\
% BYABSTIME *IntvData(Cu4_By_Absolut_Time) *\
% *IntvData(Cu4_Time_Start) *\
% *IntvData(Cu4_Time_End) *\
% FACTOR *IntvData(Cu4_Factor_Start) *\
% *IntvData(Cu4_Factor_End)
% *endif
% *if(strcmp(IntvData(Typ_Curve_4),"Explicit")==0)
% *IntvData(Typ_Curve_4) *\
% FUNC *IntvData(Cu4_Function) *\
% c1 *IntvData(Cu4_C1) *\
% c2 *IntvData(Cu4_C2)
% *endif
% *if(strcmp(IntvData(Typ_Curve_4),"EXPR")==0)
% EXPR FUNC *IntvData(Cu4_expression) *\
% t1 *IntvData(Cu4_Time_Start) *\
% t2 *IntvData(Cu4_Time_End)
% *endif
% *endif
% *end

\subsection{CURVE5}
\begin{verbatim}
------------------------------------------------------------CURVE5
\end{verbatim}

% *loop intervals
% *if(strcmp(IntvData(Load_Curve_5),"on")==0)
% CURVE5 *IntvData(Load_Curve_5) *\
% *if(strcmp(IntvData(Typ_Curve_5),"Polygonal")==0)
% *IntvData(Typ_Curve_5) *\
% T *IntvData(Cu5_Streamtime) *\
% BYABSTIME *IntvData(Cu5_By_Absolut_Time) *\
% *IntvData(Cu5_Time_Start) *\
% *IntvData(Cu5_Time_End) *\
% FACTOR *IntvData(Cu5_Factor_Start) *\
% *IntvData(Cu5_Factor_End)
% *endif
% *if(strcmp(IntvData(Typ_Curve_5),"Explicit")==0)
% *IntvData(Typ_Curve_5) *\
% FUNC *IntvData(Cu5_Function) *\
% c1 *IntvData(Cu5_C1) *\
% c2 *IntvData(Cu5_C2)
% *endif
% *if(strcmp(IntvData(Typ_Curve_5),"EXPR")==0)
% EXPR FUNC *IntvData(Cu5_expression) *\
% t1 *IntvData(Cu5_Time_Start) *\
% t2 *IntvData(Cu5_Time_End)
% *endif
% *endif
% *end

\subsection{FUNCT1}

Functions could be defined vector-valued (for example for initial flow-fields)
or scalar-valued (for Dirichlet values)

Example of a vector-valued function:

\begin{verbatim}
------------------------------------------------------------FUNCT1
FUNCT1 COMPONENT 0 EXPR 0.0 0.0 0.0 FUNCTION y*(1-y)/2
FUNCT1 COMPONENT 1 EXPR 0.0 0.0 0.0 FUNCTION 0 
FUNCT1 COMPONENT 2 EXPR 0.0 0.0 0.0 FUNCTION 0
FUNCT1 COMPONENT 3 EXPR 0.0 0.0 0.0 FUNCTION 0
\end{verbatim}

\begin{itemize}
\item The \kw{COMPONENT}-keyword defines the u/v/w/p- or x/y/z-component 
of the function.
\item The \kw{EXPR}-keyword indicates a function expression definition.
The expression is parsed and evaluated in the code. Possible functions
are 

\begin{center}
\begin{tabular}{|c|c|c|c|c|}\hline
acos & asin      & atan & cos  & sin  \\\hline
tan  & cosh      & sinh & tanh & exp  \\\hline
log  & log10     & sqrt & ceil & fabs \\\hline
floor& heaviside &      &      &      \\\hline
\end{tabular}
\end{center}
\item The three doubles after the \kw{EXPR}-keyword define the origin of
the coordinate system. The function is evaluated with respect to this origin.
\end{itemize}

Example of a scalar-valued function:

\begin{verbatim}
------------------------------------------------------------FUNCT1
FUNCT1 EXPR O_x O_y O_z FUNCTION y*(1-y)/2
\end{verbatim}

Keywords, origin and function definition as described above for vector-valued
functions. In addition to expression based functions, there exist some special
functions in the code. These BELTRAMI/KIM-MOIN functions can be seen in the
corresponding fluid test files.

\subsection{FUNCT2}
\begin{verbatim}
------------------------------------------------------------FUNCT2
\end{verbatim}
See definition of \kw{FUNCT1}

\subsection{FUNCT3}
\begin{verbatim}
------------------------------------------------------------FUNCT3
\end{verbatim}
\ldots

\subsection{LOCSYS1}
\begin{verbatim}
-----------------------------------------------------------LOCSYS1
\end{verbatim}

% *if(strcmp(GenData(Locsys_1),"on")==0)
% LOCSYS1 *GenData(Locsys_typ_1) *\
% *if(strcmp(GenData(Locsys_typ_1),"BASEVEC")==0)
% XLOC *\
% *GenData(Ls1_xloc1) *\
% *GenData(Ls1_xloc2) *\
% *GenData(Ls1_xloc3) *\
% YLOC *\
% *GenData(Ls1_yloc1) *\
% *GenData(Ls1_yloc2) *\
% *GenData(Ls1_yloc3) *\
% ZLOC *\
% *GenData(Ls1_zloc1) *\
% *GenData(Ls1_zloc2) *\
% *GenData(Ls1_zloc3)
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via three basevectors
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_1),"LINEPLANE")==0)
% LINEID *\
% *GenData(Ls1_lineId) *\
% *GenData(Ls1_plane)
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via a line (xdir) and a plane
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_1),"LINELINE")==0)
% LINEIDX *GenData(Ls1_lineIdX) *\
% LINEIDY *GenData(Ls1_lineIdY) *\
% LINEIDZ *GenData(Ls1_lineIdZ)
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via two lines (one has to be -1)
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_1),"FLUIDMASSCONS")==0)

% *endif
% *if(strcmp(GenData(Locsys_typ_1),"None")==0)

% *endif
% *endif

\subsection{LOCSYS1}
\begin{verbatim}
-----------------------------------------------------------LOCSYS2
\end{verbatim}

% *if(strcmp(GenData(Locsys_2),"on")==0)
% LOCSYS2 *GenData(Locsys_typ_2) *\
% *if(strcmp(GenData(Locsys_typ_2),"BASEVEC")==0)
% XLOC *\
% *GenData(Ls2_xloc1) *\
% *GenData(Ls2_xloc2) *\
% *GenData(Ls2_xloc3) *\
% YLOC *\
% *GenData(Ls2_yloc1) *\
% *GenData(Ls2_yloc2) *\
% *GenData(Ls2_yloc3) *\
% ZLOC *\
% *GenData(Ls2_zloc1) *\
% *GenData(Ls2_zloc2) *\
% *GenData(Ls2_zloc3)
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via three basevectors
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_2),"LINEPLANE")==0)
% LINEID *\
% *GenData(Ls2_lineId) *\
% *GenData(Ls2_plane)
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via a line (xdir) and a plane
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_2),"LINELINE")==0)
% LINEIDX *GenData(Ls2_lineIdX) *\
% LINEIDY *GenData(Ls2_lineIdY) *\
% LINEIDZ *GenData(Ls2_lineIdZ)
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via two lines (one has to be -1)
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_2),"FLUIDMASSCONS")==0)

% *endif
% *if(strcmp(GenData(Locsys_typ_2),"None")==0)

% *endif
% *endif

\subsection{LOCSYS3}
\begin{verbatim}
-----------------------------------------------------------LOCSYS3
\end{verbatim}

% *if(strcmp(GenData(Locsys_3),"on")==0)
% LOCSYS3 *GenData(Locsys_typ_3) *\
% *if(strcmp(GenData(Locsys_typ_3),"BASEVEC")==0)
% XLOC *\
% *GenData(Ls3_xloc1) *\
% *GenData(Ls3_xloc2) *\
% *GenData(Ls3_xloc3) *\
% YLOC *\
% *GenData(Ls3_yloc1) *\
% *GenData(Ls3_yloc2) *\
% *GenData(Ls3_yloc3) *\
% ZLOC *\
% *GenData(Ls3_zloc1) *\
% *GenData(Ls3_zloc2) *\
% *GenData(Ls3_zloc3)
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via three basevectors
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_3),"LINEPLANE")==0)
% LINEID *\
% *GenData(Ls3_lineId) *\
% *GenData(Ls3_plane)
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via a line (xdir) and a plane
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_3),"LINELINE")==0)
% LINEIDX *GenData(Ls3_lineIdX) *\
% LINEIDY *GenData(Ls3_lineIdY) *\
% LINEIDZ *GenData(Ls3_lineIdZ)
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via two lines (one has to be -1)
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_3),"FLUIDMASSCONS")==0)

% *endif
% *if(strcmp(GenData(Locsys_typ_3),"None")==0)

% *endif
% *endif

\subsection{LOCSYS4}
\begin{verbatim}
-----------------------------------------------------------LOCSYS4
\end{verbatim}

% *if(strcmp(GenData(Locsys_4),"on")==0)
% LOCSYS4 *GenData(Locsys_typ_4) *\
% *if(strcmp(GenData(Locsys_typ_4),"BASEVEC")==0)
% XLOC *\
% *GenData(Ls4_xloc1) *\
% *GenData(Ls4_xloc2) *\
% *GenData(Ls4_xloc3) *\
% YLOC *\
% *GenData(Ls4_yloc1) *\
% *GenData(Ls4_yloc2) *\
% *GenData(Ls4_yloc3) *\
% ZLOC *\
% *GenData(Ls4_zloc1) *\
% *GenData(Ls4_zloc2) *\
% *GenData(Ls4_zloc3)
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via three basevectors
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_4),"LINEPLANE")==0)
% LINEID *\
% *GenData(Ls4_lineId) *\
% *GenData(Ls4_plane)
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via a line (xdir) and a plane
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_4),"LINELINE")==0)
% LINEIDX *GenData(Ls4_lineIdX) *\
% LINEIDY *GenData(Ls4_lineIdY) *\
% LINEIDZ *GenData(Ls4_lineIdZ)
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via two lines (one has to be -1)
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_4),"FLUIDMASSCONS")==0)

% *endif
% *if(strcmp(GenData(Locsys_typ_4),"None")==0)

% *endif
% *endif

\subsection{LOCSYS5}
\begin{verbatim}
-----------------------------------------------------------LOCSYS5
\end{verbatim}

% *if(strcmp(GenData(Locsys_5),"on")==0)
% LOCSYS5 *GenData(Locsys_typ_5) *\
% *if(strcmp(GenData(Locsys_typ_5),"BASEVEC")==0)
% XLOC *\
% *GenData(Ls5_xloc1) *\
% *GenData(Ls5_xloc2) *\
% *GenData(Ls5_xloc3) *\
% YLOC *\
% *GenData(Ls5_yloc1) *\
% *GenData(Ls5_yloc2) *\
% *GenData(Ls5_yloc3) *\
% ZLOC *\
% *GenData(Ls5_zloc1) *\
% *GenData(Ls5_zloc2) *\
% *GenData(Ls5_zloc3)
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via three basevectors
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_5),"LINEPLANE")==0)
% LINEID *\
% *GenData(Ls5_lineId) *\
% *GenData(Ls5_plane)
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via a line (xdir) and a plane
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_5),"LINELINE")==0)
% LINEIDX *GenData(Ls5_lineIdX) *\
% LINEIDY *GenData(Ls5_lineIdY) *\
% LINEIDZ *GenData(Ls5_lineIdZ) *\
% *if(GenData(Commented_Inputfile,int)==1)
% // LOCSYS via two lines (one has to be -1)
% *endif
% *endif
% *if(strcmp(GenData(Locsys_typ_5),"FLUIDMASSCONS")==0)

% *endif
% *if(strcmp(GenData(Locsys_typ_5),"None")==0)

% *endif
% *endif

\subsection{MONITORING}
\begin{verbatim}
--------------------------------------------------------MONITORING
\end{verbatim}

// FIELD globalId FLAG FLAG FLAG FLAG FLAG FLAG
// FLUID 1 - 0 0 0 0 0 0 
// STRUCTURE 2 - 0 0 0 0 0 0 
// ALE 3 - 0 0 0 0 0 0 

\subsection{END}
\begin{verbatim}
---------------------------------------------------------------END
\end{verbatim}
the end, my friend


%%
%%----------------------------

% ---PROBLEM SIZE

% This block contains the overal size of your input problem. The elements,
% nodes and materials of all involved fields are added here. 

% read in: inpctrprob() in input\_full/input\_control\_global.c

% used for: filling the respective genprob values 

% written by: preprocessor (GiD) 

% contains: 

% \begin{lyxlist}{00.00.0000}
% \item [{ELEMENTS}] total number of elements which are listed in the input
% file 
% \item [{NODES}] total number of FE-nodes which are listed in the input
% file 
% \item [{DIM}] number of spatial dimensions the problem uses, 2 or 3 
% \item [{MATERIALS}] number of materials defined subsequently 
% \item [{NUMDF}] maximal number of degrees of freedom to one FE node 
% \end{lyxlist}
% remarks: 

% \begin{itemize}
% \item There must be at least one material. 
% \item The PROBLEM SIZE block must not be omitted.
% \end{itemize}
% ---PROBLEM TYP 

% This block contains the general information about the type of problem
% to be solved and influences the control routine of the problem. 

% read in: inpctrprob() in input\_full/input\_control\_global.c

% used for: filling the respective genprob values 

% written by: preprocessor (GiD) but check it manually! 

% contains: 

% \begin{lyxlist}{00.00.0000}
% \item [{PROBLEMTYP}] can be Ale, Fluid, Fluid\_Structure\_Interaction,
% Optimisation, Structure, Structure\_Structure\_Interaction 
% \item [{TIMETYP}] specifies Static or Dynamic problems 
% \item [{RESTART}] step number from which to restart; 0 for no restart 
% \item [{NUMFIELD}] problem can consist of up to three (physical) fields 
% \item [{GRADERW}] flag to use gradient enhanced material model (for wall
% elements only) 
% \item [{MULTISC\_STRUCT}] flag to use structural multiscale analysis (for
% wall elements and static calculations only?) 
% \item [{TRACE}] secure or fast flag to switch tracing of subroutine structures
% on or of (works for debug only) 
% \end{lyxlist}
% remarks: 

% \begin{itemize}
% \item If a step for restart is specified, restart has to be given as additional
% program argument also . 
% \item The TRACE option is the first thing to be read from the input file
% and this is done in inptrace() in input\_full/input\_ctr\_head.c . 
% \item The PROBLEM TYP block must not be omitted
% \end{itemize}
% ---DISCRETISATION 

% This block gives the number of discretisations per field. Only the
% first discretisation is read from the input file. All additional ones
% have to be created according to the special needs of the algorithm
% used. Nodes and elements of additional discretisations do not occur
% within the total node and element numbers within the PROBLEM SIZE
% block. 

% read in: inpdis() in input\_full/input\_mesh.c 

% used for: indicating further discretisations of single fields 

% written by: hand 

% contains: 

% \begin{lyxlist}{00.00.0000}
% \item [{NUMFLUIDDIS}] number of discretisations in fluid field 
% \item [{NUMSTRUCDIS}] number of discretisations in structure field 
% \item [{NUMALEDIS}] number of discretisations in ale field (=1) 
% \end{lyxlist}
% remarks: 

% \begin{itemize}
% \item Second discretisations are needed for example for the projection method
% or multiscale methods. 
% \item The discretisation block may be omitted. One discretisation per field
% is assumed in this case.
% \end{itemize}
% ---IO 

% This block has an uncertain future. Its description is postponed since. 

% read in: inp{*} in input\_full/{*}.c 

% used for: something 

% written by: hand 

% contains: 

% \begin{lyxlist}{00.00.0000}
% \item [{KEYWORD}] meaning 
% \end{lyxlist}
% remarks: 

% \begin{itemize}
% \item Add a remark!
% \end{itemize}
% ---DESIGN DESCRIPTION

% This block contains the number of design entities. The design elements
% coincide with the geometrical objects created by the preprocessing
% tool. Design entities differ from FE entities and are linked within
% the program later on. Conditions are assigned to the design elements
% first. 

% read in: inp\_designsize() in input\_full/input\_design.c 

% used for: allocating design data structure 

% written by: preprocessor (GiD) 

% contains: 

% \begin{lyxlist}{00.00.0000}
% \item [{NDPOINT}] number of design nodes 
% \item [{NDLINE}] number of design lines 
% \item [{NDSURF}] number of design surfaces 
% \item [{NDVOL}] number of design volumes 
% \end{lyxlist}
% remarks: 

% \begin{itemize}
% \item The DESIGN DESCRIPTION must not be omitted! 
% \item All lines are mandatory. (ie. the 2D case requires NDVOL 0)
% \end{itemize}
% ---DESIGN POINTS

% This block contains the precise description of the single design points.
% The number of design points expected is given by the resprective value
% of the DESIGN DESCRIPTION. 

% read in: inp\_dnode() in input\_full/input\_design.c 

% used for: organising geometry and data structure 

% written by: preprocessor (GiD) 

% to read within one design point: 

% \begin{itemize}
% \item the points ID which must be in order (read rather than counted) 
% \item number of conditions to this node (is this ever used?) 
% \item nodal coordinates (always three values!) 
% \end{itemize}
% remarks: 

% \begin{itemize}
% \item The layer, the point was drawn in, is possibly written by GiD but
% not read. 
% \item The reading relies on the key words POINT and END POINT. 
% \item The design points can clearly not be omitted.
% \end{itemize}
% ---DESIGN LINES

% This block contains the precise description of the single design lines.
% The number of design lines expected is given by the resprective value
% of the DESIGN DESCRIPTION. 

% read in: inp\_dline() in input\_full/input\_design.c 

% used for: organising geometry and data structure 

% written by: preprocessor (GiD) 

% possible line types: 

% \begin{lyxlist}{00.00.0000}
% \item [{STLINE}] stright line between two points 
% \item [{NURBLINE}] stright line between two points (coming with extra data) 
% \item [{ARCLINE}] line is part of a circle 
% \end{lyxlist}
% to read within one design line: 

% \begin{itemize}
% \item the type of the line 
% \item the lines ID which must be in order (read rather than counted) 
% \item number of conditions to this line (is this ever used?) No.
% \item the two end points connected by this line 
% \item 2D center for ARCLINES only (is this really read?) 
% \item radius for ARCLINES only 
% \item initial angle for ARCLINES only 
% \item end angle for ARCLINES only 
% \item the total length for ARCLINES only 
% \end{itemize}
% remarks: 

% \begin{itemize}
% \item The layer, the line was drawn in, is possibly written by GiD but not
% read. 
% \item The reading relies on the respective key words. 
% \item The design lines can clearly not be omitted.
% \end{itemize}
% ---DESIGN SURFACES 

% This block contains the description of all design surfaces. The number
% of design surfaces expected is given by the resprective value of the
% DESIGN DESCRIPTION. 

% read in: inp\_dsurface() in input\_full/input\_design.c 

% used for: organising geometry and data structure 

% written by: proprocessor (GiD) 

% to read within one design surface: 

% \begin{itemize}
% \item the surface ID which must be in order (read rather than counted) 
% \item number of conditions to this surface (is this ever used?) 
% \item the number of lines surrounding this surface 
% \item to every line there is read 

% \begin{itemize}
% \item the line ID 
% \item the line orientation 
% \end{itemize}
% \end{itemize}
% remarks: 

% \begin{itemize}
% \item The layer, the surface was drawn in, is possibly written by GiD but
% not read. 
% \item The reading relies on the respective key words. 
% \item The design surfaces can clearly not be omitted.
% \end{itemize}
% ---DESIGN VOLUMES 

% This block contains the description of all design volumes. The number
% of design volumes expected is given by the resprective value of the
% DESIGN DESCRIPTION. 

% read in: inp\_dvolume() in input\_full/input\_design.c 

% used for: organising geometry and data structure 

% written by: proprocessor (GiD) 

% to read within one design volume: 

% \begin{itemize}
% \item the volume ID which must be in order (read rather than counted) 
% \item number of conditions to this volume (is this ever used?) 
% \item the number of surfaces surrounding this volume 
% \item to every surface there is read 

% \begin{itemize}
% \item the surface ID 
% \item the surface orientation 
% \end{itemize}
% \end{itemize}
% remarks: 

% \begin{itemize}
% \item The layer, the volume was drawn in, is possibly written by GiD but
% not read. 
% \item The reading relies on the respective key words. 
% \item The DESIGN VOLUME block can not be omitted but will be empty for 2D
% problems.
% \end{itemize}
% ---DESIGN POINT DIRICH CONDITIONS 

% This block ... 

% read in: inp{*} in input\_full/{*}.c

% used for: something 

% written by: hand contains: 

% \begin{lyxlist}{00.00.0000}
% \item [{KEYWORD}] meaning 
% \end{lyxlist}
% remarks: 

% \begin{itemize}
% \item Add a remark here!
% \end{itemize}

%%
%%............................references
\putbib[inparams]

