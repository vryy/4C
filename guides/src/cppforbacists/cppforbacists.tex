%%
%%############################
\input{def}





%%
%%############################
\chapter{C++ for \baci{}sts}

\begin{center}
\rule[0.5ex]{5cm}{1pt} $\circ$ \rule[0.5ex]{5cm}{1pt}\\[2ex]
{\LARGE{Michael W Gee's}}\\[3ex]
{\huge{Jump-start C++}}\\[2ex]
{\normalsize{LNM-Seminar in May 2007}}\\[-1ex]
\rule[0.5ex]{5cm}{1pt} $\circ$ \rule[0.5ex]{5cm}{1pt}\\
\parbox{9cm}{\small The seminar was given by Michael Gee to provide a
very short and quick introduction to the
essential concepts of C++. This eased the transition from C to C++
(i.e. \ccarat{} to \baci{}) for
the majority of chair members, who had no clue about C++. Certainly, these
seminar notes do not cover C++ in depth, which has not been intended, but they
might prove useful by some means or other.}
\end{center}


%%
%%============================
\section{Objectives --- A few words first}

Why C++ and Trilinos and a new discretization management?
\begin{itemize}
\item Our applications become much more complex and we need to reuse and
   integrate our groups research achievements to a much larger extend then
   before 
\item We have to become `organized' meaning we need clearly defined modules
   and objects that we can easily combine to create new
   methods. \emph{(Xfem/Mortar/Chimera turbulaent FSI with thermo coupling in
   biomechanical tissue contact 
   with noise scattering in the throat of whales or....)}
\item Our current worst bottleneck is the inflexibility and inefficiency or the current
discretization \emph{(we will have a new worst but hopefully smaller
bottleneck after this...)}
\item Another bad bottleneck is the explicit dependency on GID.
\item C++ is one appropiate language to pursue and achieve these goals (the other would
be fortran90/95), and C is not. Python, Java, Matlab etc. are not suitable for one or the
other reason, mainly performance.
\item We outsource all parallel linear (and nonlinear?) algebra to Trilinos:
   \begin{itemize}
   \item Trilinos is C++ at the user/developer level and fortran77/c at the
   kernel
   \item Trilinos is LGPL
   \item Trilinos is close to our style of parallel thinking (dom. decomp., MPI)
   \item Trilinos is very powerful and very mature in all basic subpackages
   \end{itemize}
\item Integrating the mature Trilinos basic subpackages (Epetra, AztecOO, NOX, ML, Ifpack,
Amesos, Teuchos) lets us easily play with the less mature but maybe useful other
packages as well (Rythmos, Loca, Meros, Anaszasi, Thyra, PyTrilinos ....)
\end{itemize}

\section{Features of C++ new to C programmers (\ccarat{}ists)}
\begin{itemize}
\item Some of the C++ features unfamiliar to C\\
      cout/new/delete/string/{}/bool/namespaces/reference/files/
      overloading
\item Classes\\
    basic classes / public, private, protected
    virtual classes / pure virtual classes / inheritance
    casting
    Templates \& STL
    templates / vector / map / multimap / iterators
\end{itemize}

\section{Namespaces}
Example:\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
// declaration
namespace DRT;
{
   void Myfunction(...);
   void Myfunction2(...);
}
// definition
void DRT::Myfunction(...)
{
   // whatever this function does
   return;
}

// usage:
DRT::Myfunction(...);

// or:
using namespace DRT;
Myfunction(...);
\end{verbatim}
\end{boxedminipage}

\section{Output with \texttt{std::cout}}
Example:\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
using namespace std;

// cout is a stream to stdout
cout << "Hello world\n";
// or
cout << "Hello world" << endl;

// or
cout << "a + b = 1 : " << 1 << " + " << 5 << " = " << 1+5 << endl;

// often, more abstract objects 'implement the ostream <<' operation
// e.g.
ostream& operator << (ostream& os, const DRT::Element& ele)
{
   // printing the element here
}

// usage then
DRT::Element myelement;
cout << myelement;

// there is also stuff like cin, cerr etc.....

// often it is more convenient to do c-style printing
printf("In %d cases, c is more convenient to print\n",5);
\end{verbatim}
\end{boxedminipage}

\section{Allocation and deallocation with \texttt{new} / \texttt{delete}}
Example:\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
// c style malloc is 'new' in c++
int* ptr = new int[50];

// c style free is 'delete' in c++
delete [] ptr;

// CAREFUL:

// Allocate and delete an array of things
// (see above)

// Allocate and delete single object
DRT::Node* nodeptr = new Node(...);
delete nodeptr;

// do NOT mix delete and delete [] and c and c++ style

// you can NOT do
DRT::Node* nodeptr = new Node(...)[50];
delete [] nodeptr;
// -> works only with objects that have an 'empty constructor' like int
\end{verbatim}
\end{boxedminipage}

\section{Boolean type : \texttt{bool}}
Example:\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
// c++ has a separate boolean variable type

bool wantthis = true;
...
if (wantthis)
{
   ...
}
...
wantthis = false;

// works of course as every other standard variable:
bool* boolvec = new bool[30];
boolvec[17] = false;
delete [] boolvec;

// (under the hood, its actually an integer and can be used as such)
\end{verbatim}
\end{boxedminipage}

\section{Block \{\}}
Example:\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
// in a c++ code you can define a variable at any place
void myfunction(....)
{
   double a = 5.0;
   double b = 7.0;
   
   {
   double c = a+b;
   }

   double d = c; // this is wrong, c does not exist here

   for (int i=0; i<10; ++i)
   {       
       double sum = a+b+d;
       sum *= i;
   }       
}
\end{verbatim}
\end{boxedminipage}
Note that a variable exists only in the $\{\}$ where it was declared
\begin{itemize}
\item[$\to$] \kw{c} exists only inside its $\{\}$
\item[$\to$] \kw{i} exist only inside the loop
\item[$\to$] sum exists only inside the loop (making this loop somewhat useless)
\item[$\to$] the synthax for \kw{i} helps the compiler determine that nobody messes with \kw{i}
\end{itemize}

\section{References}
Example 1:\\
\begin{minipage}{0.45\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
void myfunction(....)
{
   {
       // c-style reference
       int i = 5;
       int* iptr;
       iptr = &i;
       *iptr = 7;
   }

   {
       // c++ style reference
       int i = 5;
       int& iref = i;
       iref = 7;
   }

   int j = 13;
   // wrong! not referencing
   // anything, won't compile
   int& jref;
   jref = j;
}
\end{verbatim}
\end{boxedminipage}
\end{minipage}
\hfill
\begin{minipage}{0.45\linewidth}
Note:\\
Unlike fortran, c only has
call-by-value. If you need a
call-by-reference,
a call-by-value on the
adress of an object is made
\\[1.5cm]

C++ has a true call by reference
(reference operator \&)
\\[1.5cm]

One can not have a reference variable
not referencing anything. This way, a
reference (unlike a pointer) is always
well defined and valid.
\end{minipage}

Example 2:\\
\begin{minipage}{0.45\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
void myfunction(....)
{
   // c-style call-by-reference
   int i = 5;
   AddTwo(&i);
}

AddTwo(int* i)
{
   *i += 2;
   return;
}

void myfunction_cpp(....)
{
   // c++-style call-by-reference
   int i = 5;
   AddTwo2_cpp(i);
}

AddTwo_cpp(int& i)
{
   i += 2;
   return;
}
\end{verbatim}
\end{boxedminipage}
\end{minipage}
\hfill
\begin{minipage}{0.45\linewidth}
\vspace*{3cm}
Don't have to mess with all this pointer/
adress business, just use a call by reference
or a call by value

Cannot have bad references as one can
have bad pointers

A reference is always `good' otherwise
the compiler notices.
\end{minipage}

\section{Files}
Header file containg declarations: \textbf{node.H}\\
\begin{minipage}{0.45\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
// file description comment
#ifndef NODE_H
#define NODE_H

// some declarations
// doxygen docu of nodefunction1
void nodefunction1(...);
// doxygen docu of nodefunction2
int nodefunction2(...);

#endif // end of header file
\end{verbatim}
\end{boxedminipage}
\end{minipage}
\hfill
\begin{minipage}{0.45\linewidth}
multiple and nested inclusions
of \textbf{node.H} are ok due to \kw{NODE_H}

C++ does \emph{not tolerate} multiple
declarations
\end{minipage}

\section{Overloading}
Overloading can help save brain power
(Just remember there was a TwiceThis method
that worked for all reasonable data
types)

Example: \textbf{node.H}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
// file description comment
#ifndef NODE_H
#define NODE_H

// some declarations
void TwiceThis(const int& i);
void TwiceThis(const double& i);

#endif // end of header file
\end{verbatim}
\end{boxedminipage}
and \textbf{node.cpp}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
// file description comment
#include "node.H"
#include"headthatincludesnodeaswell.H"

// short comment on AddThis
void TwiceThis(const int& i)
{
   i = i*2;
}
// short comment on AddThis
void TwiceThis(const double& i)
{
   i = i*2.0;
}
\end{verbatim}
\end{boxedminipage}
Be very reasonable, one can do a lot
of nonsense with overloading\ldots, e.g.\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
void TwiceThis(const double& i)
{
   i = i*i;
}
\end{verbatim}
\end{boxedminipage}

\section{Classes}
A class is something like a struct:
it can hold data (int, double, etc)
it can also hold functions
it protects its data and functions by
classifying it as public/protected/private

\subsection{\texttt{public}/\texttt{private}/\texttt{protected}}
Example: \textbf{animal.H}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
// file contains class Animal
#ifndef ANIMAL_H
#define ANIMAL_H

// declaration of class
class Animal
{
public:
   // stuff that can be accessed from
   // outside the class
   int pubi_;

protected:
   // stuff that can be accessed from
   // under certain circumstances
   // (later)
   int protj_;
   
private:
   // stuff that is invisible to
   // the outside world
   int privk_;
   
}; // end of class Animal
#endif // end of header file
\end{verbatim}
\end{boxedminipage}
and \textbf{animal.cpp}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
#include "animal.H"

...

{
   // create an instance of Animal
   Animal myanimal;
   myanimal.pubi_ = 5; // ok

   // might be ok if i'm either
   // a friend of Animal
   // or derived from Animal here (later)
   myanimal.protj_ = 7;
   
   myanimal.privk_ = 13; // won't compile
}
\end{verbatim}
\end{boxedminipage}
\kw{private} data can only be accessed (read/write)
by the class' own functions

\subsection{Methods}
A function inside a class is called a method.
All methods can access \kw{private}/\kw{protected} data.

Example: \textbf{animal.H}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
// file contains class Animal
#ifndef ANIMAL_H
#define ANIMAL_H

// declaration of class
class Animal
{
public:

   int Returnk()
   {
       return privk_;
   }
   
   int pubi_;

protected:

   int protj_;

private:

   int privk_;

}; // end of class Animal
#endif // end of header file
\end{verbatim}
\end{boxedminipage}
and \textbf{some.cpp}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
#include "animal.H"
...
{
   // create an instance of Animal
   Animal myanimal;
   myanimal.pubi_ = 5; // ok

   // might be ok if i'm either
   // a friend of Animal
   // or derived from Animal here (later)
   myanimal.protj_ = 7;

   // ok, note that k is a copy of
   // privk_ !
   double k = myanimal.Returnk();
}
\end{verbatim}
\end{boxedminipage}
Private/Protected data can only be accessed
(read/write) by the class' own methods

One can also have private methods, that can
only be called by other methods of the class

\paragraph{Good practice}
Never grant unlimited public access
to your data.
Data should be at least protected.

Example: \textbf{animal.H}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
// file contains class Animal
#ifndef ANIMAL_H
#define ANIMAL_H

// declaration of class
class Animal
{
public:
   
   int ReturnI() { return i_; }

   int* AccessI() { return &i_; }

   int ReturnJ() { return j_; }

   int& ReturnKRef() { return k_; }

protected:

private:

   int i_;
   int j_;
   int k_;
   
}; // end of class Animal
#endif // end of header file
\end{verbatim}
\end{boxedminipage}
and \textbf{some.cpp}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
#include "animal.H"
...
{
   // create an instance of Animal
   Animal myanimal;

   int i = myanimal.ReturnI();
   int* iptr = myanimal.AccessI();
   *iptr = 7; // nice
   *(myanimal.AccessI()) = 7; // nice?

   int& kref = myanimal.ReturnKRef();
   kref = 17; // nicer
   myanimal.ReturnKRef() = 17; // nice?
}
\end{verbatim}
\end{boxedminipage}

\subsection{Ctor, cctor and dtor}
ctor: constructor, cctor: copy-constructor and dtor: destructor

Example: Declarations\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
class Animal
{
public:

   // constructor (identified by same name as class)
   Animal(int j);

   // another constructor (empty)
   Animal();

   // copy constructor
   Animal(const Animal& olda);

   // destructor
   ~Animal();

   // some method (definition missing)
   MyMethod(int fool);

protected:

private:

   int j_;
   int* myvec_; // vector length j_

}; // end of class Animal
\end{verbatim}
\end{boxedminipage}
and their defintions\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
Animal::Animal(int j)
{
   j_ = j;
   myvec_ = new int[j_];
   return;
}

Animal::Animal()
{
   j_ = -1;
   myvec_ = nullptr;
   return;
}

Animal::Animal(const Animal& olda)
{
   j_ = olda.j_;
   myvec_ = new int[j_];
   for (int i=0; i<j_; ++i)
       myvec_[i] = olda.myvec_[i];
   return;
}

Animal::~Animal()
{
   if (myvec_) delete [] myvec_;
   return;
}
\end{verbatim}
\end{boxedminipage}

\paragraph{Good practice}
Example: \\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
class Animal
{
public:

   // constructor
   Animal(int j);

   // another constructor (empty)
   Animal();

   // destructor
   ~Animal();

   // some method (definition missing)
   MyMethod(int fool);

protected:

private:

   // do not want copy-ctor
   Animal(const Animal& old);

   // do not want = operator
   Animal operator = (const Animal& old);
}; // end of class Animal
\end{verbatim}
\end{boxedminipage}
If you do not define
copy constructor and \kw{=} operator,
the compiler will automatically generate
default versions of them which
might show unexpected behavior\\
$\Longrightarrow$ declare private to be sure
not to have them

\subsection{More good practice}
Example:\\
\begin{minipage}{0.45\linewidth}
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
class Animal
{
public:

   // constructor
   Animal(int j);

   // another constructor (empty)
   Animal();

   // destructor
   ~Animal();

   // some method (definition missing)
   MyMethod(int fool);

protected:

private:

   // do not want copy-ctor
   Animal(const Animal& old);

   // do not want = operator
   Animal operator = (const Animal& old);

}; // end of class Animal
\end{verbatim}
\end{boxedminipage}
\end{minipage}
\hfill
\begin{minipage}{0.45\linewidth}
--- namespaces are ALL capital, e.g.
\begin{verbatim}
namespace DISCRETIZATION;
\end{verbatim}

--- classes are captial and small, e.g.
\begin{verbatim}
class LineElement;
\end{verbatim}

--- Methods and functions are
capital and small, e.g.
\begin{verbatim}
int i = MyMethod();
\end{verbatim}

--- variables and instances are ALL
small, e.g.
\begin{verbatim}
int i;
Solid3 myelement(...);
\end{verbatim}

--- variables/instances inside classes
end with an underscore, e.g.:
\begin{verbatim}
class Animal
{
   int i_;
   Node& mynode_;
}
\end{verbatim}
\end{minipage}

\subsection{Virtual/derived classes}
Create a class for an Element\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
class Element
{
   Element(int id, int nnode, int* nodeids);
   Element(const Element& old);
   virtual ~Element();

   virtual int Id()
   { return id_; }

   virtual int NumNode()
   { return nnode_; }

   virtual int* NodeIds()
   { return nodeids_; }

protected:
   int id_;
   int nnode_;
   int* nodeids_;
   
}; // end of class Element
\end{verbatim}
\end{boxedminipage}
A virtual class is basically a class that
declares at least its destructor 'virtual'
Now, we need about x different types of
elements (shell, fluid3, solid3, ale2 ...)
We could:
\begin{itemize}
\item store ALL of their specific data
in Element
\item Create a separate Element class
for each of them and make the
discretization handle them all
(a lot of if's and switches)
\item use derived classes
\item other ways not discussed here...
\end{itemize}

Create a class for an Element: \textbf{``base class''}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
class Element
{
   Element(int id, int nnode, int* nodeids);
   Element(const Element& old);
   virtual ~Element();
   
   virtual int Id()
   { return id_; }

   virtual int NumNode()
   { return nnode_; }

   virtual int* NodeIds()
   { return nodeids_; }

protected:

   int id_;
   int nnode_;
   int* nodeids_;
}; // end of class Element
\end{verbatim}
\end{boxedminipage}
and \textbf{``derived class''}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
Solid3::~Solid3()
{
   material_ = -1; // useless...
   return;
}

class Solid3 : public Element
{
   Solid3(int id, int nnode, int* nodeids, int material);

   Solid3(const Solid3& old);

   virtual ~Solid3();

   int Material()
   { return material_; }

protected:

   int material_;
   
}; // end of class Solid3

Solid3::Solid3(int id, int nnode, int* nodeids, int material) : Element(id,nnode,nodeids)
{
   material_ = material;
}

Solid3::Solid3(const Solid3& old) : Element(old)
{
   material_ = old.material_;      
}
\end{verbatim}
\end{boxedminipage}
and an object of \kw{Solid3} is created by\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
{
   int nnode = 4;
   int* ids = new int[nnode]; // fill this...
   Solid3 myele(1,nnode,ids,7);
   delete [] ids;

   int eleid = myele.Id();
   int nn = myele.NumNode();
   int* nodeids = myele.NodeIds();
   int mat = myele.Material();
}
\end{verbatim}
\end{boxedminipage}

Virtual \kw{NodeIds} method is handled in \textbf{``base class''}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
class Element
{
   Element(int id, int nnode, int* nodeids);
   Element(const Element& old);
   virtual ~Element();

   virtual int Id()
   { return id_; }

   virtual int NumNode()
   { return nnode_; }

   virtual int* NodeIds()
   { return nodeids_; }

protected:

   int id_;
   int nnode_;
   int* nodeids_;

}; // end of class Element
\end{verbatim}
\end{boxedminipage}
and \emph{as well} in \textbf{``derived class''}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
class Solid3 : public Element
{
   Solid3(int id, int nnode, int* nodeids, int material);

   Solid3(const Solid3& old);

   virtual ~Solid3();

   int* NodeIds() { return nullptr; }

   int Material()
   { return material_; }

protected:

   int material_;

}; // end of class Solid3
\end{verbatim}
\end{boxedminipage}
We get the following results by just looking at the Element part of Solid3:\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
{
   ...
   Solid3 myele(1,nnode,ids,7);
   Element& baseele = myele; // this is the base type!, works fine
   // always returns nullptr as well!
   int* nodeids = baseele.NodeIds();
}
\end{verbatim}
\end{boxedminipage}
A derived class can reimplement a base class method:\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
{
   ...
   Solid3 myele(1,nnode,ids,7);
   // always returns nullptr !
   int* nodeids = myele.NodeIds();
}
\end{verbatim}
\end{boxedminipage}
$\Longrightarrow$ Search order\\
\begin{tabular}{|l|l|l|}
\hline
class type & function type & search order
\\ \hline\hline
derived & normal & derived, then base
\\ \hline
base & normal & base
\\ \hline
derived & virtual & derived, then base
\\ \hline
base & virtual & derived, then base
\\ \hline
\end{tabular}

\subsection{Pure virtual classes}
Create a base class for an Animal (e.g. number of legs)\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
class Animal
{
   Animal();
   Animal(const Animal& old);
   virtual ~Animal();

   virtual int Nlegs() = 0;  // here is the show: '= 0'
   (...) // other stuff

private:

   // do not want these
   Animal(const Animal& old);
   Animal operator = (const Animal& old);
   
}; // end of class Animal
\end{verbatim}
\end{boxedminipage}
`Animal' is \emph{pure virtual}, one can not have an instance of Animal:\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
{
   Animal myanim; // this will not compile
}
\end{verbatim}
\end{boxedminipage}
Animal is ment to derive from, you cannot use Animal itself.

Create a class for an elephant\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
class Elephant : public Animal
{
   Elephant();
   Elephant(const Elephant& old);
   virtual ~Elephant();

   int Nlegs() { return 4; }

private:
   
   // do not want these
   Elephant(const Elephant& old);
   Elephant operator = (const Elephant& old);

}; // end of class Elephant
\end{verbatim}
\end{boxedminipage}
Create a class for a honeybee\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
class Hbee : public Animal
{
   Hbee();
   Hbee(const Hbee& old);
   virtual ~Hbee();

   int Nlegs() { return 6; }

private:

   // do not want these
   Hbee(const Hbee& old);
   Hbee operator = (const Hbee& old);
   
}; // end of class Hbee
\end{verbatim}
\end{boxedminipage}

\subsection{Dynamic and static casting}
Example: \textbf{``Base class''}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
class Element
{
   Element(int id, int nnode, int* nodeids);
   Element(const Element& old);

   virtual ~Element();
   virtual int Id()
   { return id_; }

   virtual int NumNode()
   { return nnode_; }

   virtual int* NodeIds()
   { return nodeids_; }

protected:

   int id_;
   int nnode_;
   int* nodeids_;
   
}; // end of class Element
\end{verbatim}
\end{boxedminipage}
and \textbf{`derived class''}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
class Solid3 : public Element
{
   Solid3(int id, int nnode, int* nodeids, int material);

   Solid3(const Solid3& old);

   virtual ~Solid3();

   int Material()
   { return material_; }

protected:

   int material_;

}; // end of class Solid3
\end{verbatim}
\end{boxedminipage}
We can cast:\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
{
   const Solid3 myele(1,nnode,ids,7);
   Solid3& eleref = const_cast<Solid3&>(myele); // bad, explicit cast-away constness
   Element& baseele = dynamic_cast<Element&>(eleref); // good
   Element* bptr = dynamic_cast<Element*>(&eleref); // good
   Element* bptr = static_cast<Element*>(&eleref); // brutal
   Element* bptr = (Element*)(&eleref); // c-style brutal
}
\end{verbatim}
\end{boxedminipage}

\section{Template}
A template is not a real piece of code, but an instruction to generate a piece of
code if required:\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
template<typename T> void SwapTheseTwo(T& a, T& b)
{
T tmp = a;
a = b;
b = tmp;
return;
};
\end{verbatim}
\end{boxedminipage}
And a `specialization' of \kw{SwapTheseTwo} for \kw{Element}\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
template<> void SwapTheseTwo(Element& a, Element& b)
{
   // here swap the contents of the two elements a and b
   return;
}
\end{verbatim}
\end{boxedminipage}
`Real' code for \kw{<typename int>} and \kw{<typename
double>} versions of ``\kw{SwapTheseTwo}'' is generated
by the compiler at link time and compiled.
For \kw{<Element>} the compiler uses the supplied
specialization.\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
{
   int i = 5;
   int j = 7;
   SwapTheseTwo(i,j);

   double x = 6.34;
   double y = 3.141;
   SwapTheseTwo(x,y);

   Element a(5,nodeids,false);
   Element b(7,nodeids2,true);
   SwapTheseTwo(a,b);
}
\end{verbatim}
\end{boxedminipage}
\begin{itemize}
\item One can have template functions, methods and classes
\item Bugs in templates can be very hard to find, they are hard to debug and often produce
very kryptic compiler/linker messages leaving no clue what the problem might be.
\item Usage of templates (especially those from the STL) is desired in \baci{}.
\item Creation of templates is in general not encouraged as they can be very hard to
understand for (future) coworkers
\item Create templates iff you feel absolutely comfortable with them!
\end{itemize}

\section{Standard Template Library (STL)}
C++ comes along with a series of very powerful and useful templates we should
excessively use. These are bundled in the so called STL.\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
#include <vector>

{
   // c- style array
   double* x = malloc(5*sizeof(double));
   if (!x) printf("Error: Allocation failed\n");
   free(x);

   // c++ conventional array
   double* x = new double[5];
   if (!x) cout << "Error: Allocation failed\n";
   delete [] x;

   // c++ stl style array
   vector<double> x(5); // constructor with a given size
   x[0] = 3.245;
   x[1] = 5.897;
   x[2] = x[0] + x[1];
   x[4] = x[2] - x[1];
   // not really necessary:
   x.clear();
   // x dies correctly when the destructor of vector is
   // called, no memory leaking!
}
\end{verbatim}
\end{boxedminipage}
An incomplete list of STL containers:\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
{
   vector<typename T>

   map<typename key, typename datatype>

   set<typename T>

   list<typename T>

   multimap<typename key, typename datatype>

   hashmap<typename key, typename datatype>

   stack<typename T>
}
\end{verbatim}
\end{boxedminipage}
We will talk more about \kw{vector}, \kw{map} and \kw{multimap}.

\subsection{Vector}
Example 1:\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
#include <vector>
{
   vector<int> ivec; // vector of length 0
   vector<double> dvec(10) // vector length 10;

   ivec.resize(50); // now length 50;
   int ilength = ivec.size(); // get length

   // iterate through ivec
   for (int i=0; i<(int)ivec.size(); ++i)
   {
       ivec[i] = i*i;
   }

   // get direct access to continuous data in dvec
   double* dptr = &devc[0];
// iterate though devc in an uncommon style
for (int i=0; i<(int)devc.size(); ++i)
{
dptr[i] = 3.141*i;
}
}
// all vectors died correctly here
\end{verbatim}
\end{boxedminipage}
More about vectors in Example 2:\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
#include <vector>

{
   // bad:
   {
       vector<int*> iptrs(10); // 10 pointers to integer
       iptrs[5] = new int[12]; // conventional c++ allocation
       iptrs.clear();          // we just leaked 12*sizeof(int) bytes
   }

   // better:
   vector<vector<int> > iptrs; // 10 vectors of length 0
   iptrs[5].resize(12);        // 9 vectors length 0, 1 length 12
   iptrs.clear();              // we leaked nothing

   vector<double> dvec(10);
   for (int i=0; i<10; ++i) dvec[i] = 3.141*i;
   dvec.push_back(10*3.141);

   int dim = dvec.size();
   dvec.resize(dvec.size()+1);

   double* dptr = &dvec[0]; // data in vector is contigous
   MPI_Send(dptr,dvec.size(),MPI_DOUBLE,...);
}
\end{verbatim}
\end{boxedminipage}
\begin{itemize}
\item A vector can hold anything, even another templated something
\item A vector calls the destructor of the data objects in the vector upon deletion,
(it does NOT call delete on pointers)
\end{itemize}

\subsection{Map}
\kw{map} is a `pair associative container':\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
#include <map>
#include <vector>
{
   map<int,double> data;                 // associates element ptrs with an int key
   data[5] = 3.141;                      // associates 5 with pi, no 0,1,2,3,4 exist!
   data[7] = 2.*3.141;                   // associates 7 with 2pi
   data.insert(pair<int,double>(9,2.7)); // the long way to insert something

   int dim = data.size(); // number of pairs in data

   data[5] = 2.*data[7]; // one should be certain that pairs with key 5,7 exist,
                         // otherwise the code will crash here
   data.delete(7);       // we deleted the pair with the key 7

   // Something a little bit more complex:
   map<string,vector<double> > myvectors; // vectors with a certain name 
                                          // mark the space '> >'
   myvectors["solution"].resize(10);      // vector ``solution" now of length 10
   myvectors["solution"][5] = 3.141;
}
// we leaked nothing here, everything was destroyed correctly
\end{verbatim}
\end{boxedminipage}
\begin{itemize}
\item data in a map is associated with a key that can also be of any type
\item data in a map is NOT contigous (its actually stored in a tree for fast access)
\item how do I get my stuff out of a map if I do not know what's exactly in there?
\end{itemize}

Map comes with something called an `iterator':\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
#include <map>
{
   map<int,double> data; // associates element ptrs with an int key
   data[5] = 3.141;      // associates 5 with pi, no 0,1,2,3,4 exist!
   data[7] = 2.*3.141;   // associates 7 with 2pi

   // now we pretend not to know what's in data and want to print
   // everything to screen
   map<int,double>::iterator current; // we create an iterator
   // looping through the map
   for (current=data.begin(); current!=data.end(); ++current)
   {
       // get the key and value of the current pair
       int key = current->first;
       double val = current->second;
   cout << "key " << key << " value " << val << endl; // print to screen
   }

   // now we want to check whether we have something with the key '9'
   // if so, print and then delete it
   map<int,double>::iterator haveit = data.find(9);
   if ( haveit != data.end() )
   {
       cout << "We have it, and it is" << endl
            << "key " << haveit->first << " value " << haveit->second << endl;
   data.delete(haveit); // data.delete(9) would work as well
   }
}
// we leaked nothing here, everything was destroyed correctly
\end{verbatim}
\end{boxedminipage}

If one associates something twice with the same key, it will be overwritten in a map:\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
#include <map>
#include <multimap>
{
   map<int,double> data; // associates element ptrs with an int key
   data[5] = 3.141;      // associates 5 with pi, no 0,1,2,3,4 exist!
   data[7] = 2.*3.141;   // associates 7 with 2pi

   // put something else in with the key '7'
   data[7] = 5.0;

   // now we lost our 2pi
}
\end{verbatim}
\end{boxedminipage}

A \kw{multimap} can have more then one thing under the very same key\\
\begin{boxedminipage}{\linewidth}
\begin{verbatim}
{
   multimap<int,double> data; // associates element ptrs with an int key
   data[5] = 3.141;           // associates 5 with pi, no 0,1,2,3,4 exist!
   data[7] = 2.*3.141;        // associates 7 with 2pi

   // put something else in with the key '7'
   data[7] = 5.0;

   // we have two pairs with key '7' know, get them
   multimap<int,double>::iterator start = data.lower_bound(7);
   multimap<int,double>::iterator end = data.upper_bound(7);
   multimap<int,double>::iterator current;
   for (current = start; current!= end; ++current)
      cout << "objects with 7 as key : " << current->second << "\n";
}
\end{verbatim}
\end{boxedminipage}
scary, the normal case would be to stay away from multimaps\ldots
